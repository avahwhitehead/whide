{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/whilejs/lib/types/position.js","webpack:///./node_modules/@whide/tree-lang/lib/converter/converter.js","webpack:///./node_modules/whilejs/lib/index.js","webpack:///./node_modules/@whide/tree-lang/lib/exceptions/ConverterException.js","webpack:///./node_modules/whilejs/lib/utils/StringBuilder.js","webpack:///./node_modules/whilejs/lib/linter/lexer/index.js","webpack:///./node_modules/whilejs/lib/types/tokens.js","webpack:///./node_modules/whilejs/lib/utils/ProgramManager.js","webpack:///./node_modules/@whide/tree-lang/lib/trees/TreeLexer.js","webpack:///./node_modules/@whide/tree-lang/lib/converter/lexer.js","webpack:///./node_modules/@whide/tree-lang/lib/converter/parser.js","webpack:///./node_modules/whilejs/lib/tools/progAsData.js","webpack:///./node_modules/whilejs/lib/linter/index.js","webpack:///./node_modules/@whide/tree-lang/lib/utils/parser.js","webpack:///./node_modules/whilejs/node_modules/tslib/tslib.es6.js","webpack:///./node_modules/@whide/tree-lang/lib/exceptions/ParserException.js","webpack:///./node_modules/@whide/tree-lang/lib/stringify.js","webpack:///./node_modules/whilejs/lib/utils/NameGenerator.js","webpack:///./node_modules/whilejs/lib/tools/displayProg.js","webpack:///./src/run/whilejs/WhilejsWorker.ts","webpack:///./node_modules/whilejs/lib/utils/VariableManager.js","webpack:///./node_modules/@whide/tree-lang/lib/trees/TreeParser.js","webpack:///./node_modules/whilejs/lib/utils/errorManager.js","webpack:///./node_modules/whilejs/lib/utils/MacroManager.js","webpack:///./node_modules/@whide/tree-lang/lib/index.js","webpack:///./node_modules/@whide/tree-lang/lib/exceptions/LexerException.js","webpack:///./node_modules/whilejs/lib/tools/astEquals.js","webpack:///./node_modules/whilejs/lib/run/Interpreter.js","webpack:///./node_modules/whilejs/lib/types/extendedTokens.js","webpack:///./node_modules/whilejs/lib/linter/parser/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","incrementPos","tslib_1","pos","str","e_1","_a","str_1","__values","str_1_1","next","done","row","col","e_1_1","error","return","__importDefault","this","mod","ConverterException_1","_readNumber","tree","cur","left","right","_treeToConverted","res","children","_treeToConversionResult","_valueToConversionResult","_parentConversionResult","_convertListInternal","conversionTree","atoms","head","_convert","type","tail","_i","length","child","push","_convertFalse","_convertTrue","_convertBoolean","_convertNumber","expected","undefined","_convertAtom","atom","atomTree","conversionResult","_convertChoice","join","_convertTree","_convertList","list","category","default","runConvert","Map","displayProgram","displayPad","fromPad","toPad","MacroManager","ProgramManager","Interpreter","parseProgram","linter","linter_1","__importStar","Interpreter_1","ProgramManager_1","MacroManager_1","progAsData_1","displayProg_1","__extends","extendStatics","b","setPrototypeOf","__proto__","Array","TypeError","String","__","constructor","ConverterException","_super","message","Error","StringBuilder","props","_level","_lines","_props","indent","linebreak","dedent","line","toString","add","text","break","_this","map","_b","__read","repeat","set","configurable","position_1","errorManager_1","tokens_1","extendedTokens_1","SYMBOL_LIST","TKN_SEP","TKN_ASSGN","TKN_BLOCK_OPN","TKN_BLOCK_CLS","TKN_PREN_OPN","TKN_PREN_CLS","EXPR_LIST","TKN_READ","TKN_WRITE","TKN_IF","TKN_ELSE","TKN_WHILE","OP_LIST","TKN_CONS","TKN_HD","TKN_TL","SYMBOL_LIST_EXTD","__spreadArray","TKN_EQL","TKN_COMMA","TKN_DOT","TKN_COLON","TKN_MCRO_OPN","TKN_MCRO_CLS","TKN_LIST_OPN","TKN_LIST_CLS","EXPR_LIST_EXTD","TKN_SWITCH","TKN_CASE","TKN_DEFAULT","OP_LIST_EXTD","TKN_TRUE","TKN_FALSE","read_identifier","program","exec","read_number","read_pad_token","token","match","read_next_token","pureOnly","e_2","e_3","_c","_d","_e","sym","substr","endPos","__assign","expr","PAD_VALUES","Number","parseInt","_f","_g","tkn","e_2_1","_h","_j","e_3_1","lexer","errorManager","ErrorManager","options","pureOny","whitespace","charAt","addError","substring","index","search","errors","VariableManager_1","NameGenerator_1","astEquals_1","_pushBodyToStack","stack","body","prog","_prog","_variableManager","_variablePositions","_macros","_macroPositions","reanalyse","data","variableManager","variables","from","keys","entries","setProg","_analyseProgram","replaceMacro","macro","convertToPure","namespace","namespaceExists","getNewNamespace","macroPositions","macroPosition","macroExpr","macroManager","toPure","v","newName","renameVariable","pre","complete","ident","input","arg","parent_body","indexOf","parent_cmd","splice","apply","output","oldname","newname","positions","forEach","delete","newpos","_analyseExpr","cmd","_analyseCmd","parentBody","cmd_1","pop","condition","else","if","cases","cond","parentCommand","expr_1","args","arg2","arg1","elements","macros","e_4","equalsMacroName","nameGenerator","macroCounts","has","name_1","macro1","includes","e_4_1","_bodyToPure","e_5","body_1","body_1_1","_cmdToPure","e_5_1","_exprToPure","_switchToPure","sw","dflt","root","prevIf","_listToPure","lst","op","_treeExprToPure","_treeToPure","nil","treeStack","opStack","_addChildTree","subtree","tree_1","TKN_DO_CONS","TKN_DO_TL","TKN_DO_HD","TKN_QUOTE","TKN_VAR","TKN_DO_IF","TKN_DO_WHILE","TKN_DO_ASSIGN","TKN_ASSIGN_1","TKN_ASSIGN","TKN_NIL","lexer_1","TOKEN_LIST","lexTree","TKN_TREE_CLS","TKN_TREE_OPN","TKN_CTR","TKN_BAR","TKN_DOTS","LexerException_1","literals","startingLength","trimStart","_checkForSymbolToken","num","_checkForNumberToken","_checkForAtomToken","_unexpectedToken","_isTokenAllowed","SYMBOL_LIST_1","parser_1","ParserException_1","_isList","tokens","shift","_expect","_addToChoice","parent","_interpretListInternal","_readAllAtoms","_readAtom","first","_interpretTree","_interpretParen","_interpretList","parse","HWHILE_DISPLAY_FORMAT","PURE_DISPLAY_FORMAT","StringBuilder_1","manager","VariableManager","programBody","el","_convertToData","_convertToDataExpr","addAnonymous","_cmdFromPad","cmdStack","data_1","cmds","parentCmds","_exprFromPad","exprStack","data_2","parent_1","format","builder","commandStack","_displayBody","_evalDisplayStack","_displayBodyClose","level","terminator","currLevel","assign","while","var","quote","cons","hd","tl","lint","lexerOpts","lexOpts","parseOpts","lexErrors","parseErrors","ast","to","il","j","actual","arguments","__rest","e","getOwnPropertySymbols","propertyIsEnumerable","__decorate","decorators","target","desc","getOwnPropertyDescriptor","Reflect","decorate","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","rejected","result","then","__generator","f","y","g","_","label","sent","trys","ops","verb","iterator","__createBinding","k","k2","__exportStar","ar","__spread","concat","__spreadArrays","a","jl","pack","slice","__await","__asyncGenerator","asyncIterator","q","resume","settle","fulfill","__asyncDelegator","__asyncValues","__makeTemplateObject","cooked","raw","__setModuleDefault","__classPrivateFieldGet","receiver","state","kind","__classPrivateFieldSet","ParserException","buildChildren","sep","stringify","stringifyVal","NameGenerator","minLength","_nextName","increment","_incrementName","looped","_nextChar","code","charCodeAt","fromCharCode","stringBuilder","_displayCmd","_displayExpr","brackets","_displayTree","post","isRight","_emit","self","postMessage","_emitErr","msg","_emitDone","_emitLoaded","interpreter","addEventListener","event","req","run","VariableNamespaceManager","opts","_variableMap","_variableLookup","_varNameGenerator","minVarLen","_namespaceGenerator","force","DEFAULT_NS","getNextVarName","exists","remove","val","deleteNamespace","mgr","Set","lookupVariable","_variables","_names","_ptr","variable","TreeLexer_1","_numberToTree","_tokensToTree","tokenList","_errors","position","_unregistered","_macroMap","register","macroName","values","size","getNextUnregistered","_iterator","autoRegister","cbk","hasUnregistered","treeParser","converter_1","stringify_1","TreeParser_1","_runParse","conversionString","default_1","customAtoms","parseResult","converter","LexerException","_idnt","_assign","_operation","_while","_if","bodyIf","bodyElse","nil_token","false_token","true_token","EQUALS_PROG","_program","_input","_store","_exprStack","_commandStack","inputTree","lexerErrors","success","treeEquals","sNodes","tNodes","sn","tn","_runCommandStack","_evalExpr","_copyExpr","_evalExprStack","caseFound","cse","caseCond","curr","evaled","_replaceArgWithLiteral","copy","par","literal","TKN_PAD_DO_CONS","TKN_PAD_CONS","TKN_PAD_DO_TL","TKN_PAD_TL","TKN_PAD_DO_HD","TKN_PAD_HD","TKN_PAD_QUOTE","TKN_PAD_VAR","TKN_PAD_DO_IF","TKN_PAD_IF","TKN_PAD_DO_WHILE","TKN_PAD_WHILE","TKN_PAD_DO_ASSIGN","TKN_PAD_ASSIGN_1","TKN_PAD_ASSIGN","ParseStatus","astIdent","astOp","unexpectedToken","unexpectedValue","unexpectedEOI","StateManager","_errorManager","_tokens","_lastToken","_pos","_endPos","expect","_next","EOI","OK","expected_1","expected_1_1","exp","ERROR","peek","consumeUntil","expected_2","expected_2_1","unexpectedEOICustom","unexpectedTokenCustom","_numToTree","_isValidVariableName","_readExpr","checkEq","_readExprInt","status_1","exprStatus","close_1","exprState","leftStatus","rightStatus","status_2","_readListBody","lstStatus","lstBody","_readTreeOrMacro","resStat","nextStatus","status","statementStatus","statement","next_1","_readTreeBody","dotStatus","clsStatus","status_3","progName","inpStatus","inp","_readElse","_readBlock","_readStatementList","_readStmt","_readCase","_readCaseBody","colonStat","bodyStatus","caseTkn","caseStatus","_readSwitch","inpExpr","opnStatus","condStatus","ifState","ifBlock","elseState","elseBlock","status_4","bodyState","status_5","isVarValid","assgnStatus","valStatus","clsStat","_readProgramIntro","_readInput","_readRead","read","inputStatus","inputVar","_readProgramOutro","err","write","outputVar","_readProgram","outputStatus","progInStatus","final","parser","stateManager"],"mappings":"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","file":"js/WhilejsWorker.50c982e7.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/whide/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"a361\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.incrementPos = void 0;\nvar tslib_1 = require(\"tslib\");\n;\n/**\n * Automatically increment the row/column pointers to a position object from a string.\n * At each {@code \\n} the row counter is incremented and the column counter reset.\n * Every other character increments the column counter.\n * @param pos\tThe Position object\n * @param str\tthe string to use to increment the pointer.\n */\nfunction incrementPos(pos, str) {\n    var e_1, _a;\n    try {\n        for (var str_1 = tslib_1.__values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {\n            var c = str_1_1.value;\n            if (c === '\\n') {\n                pos.row++;\n                pos.col = 0;\n            }\n            else {\n                pos.col++;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\nexports.incrementPos = incrementPos;\n//# sourceMappingURL=position.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ConverterException_1 = __importDefault(require(\"../exceptions/ConverterException\"));\n//========\n// Utils\n//========\n/**\n * Gets the value of a tree if it is treated as a number.\n * Returns undefined if the number is not strictly a valid number (i.e. the left node is not `null` at any point)\n * @param tree\tThe tree to interpret\n * @param cur\tThe starting value (default 0)\n * @returns the number represented by the tree, or `undefined` if not available\n */\nfunction _readNumber(tree, cur) {\n    if (cur === void 0) { cur = 0; }\n    if (tree === null)\n        return cur;\n    if (tree.left === null)\n        return _readNumber(tree.right, cur + 1);\n    return undefined;\n}\n/**\n * Convert a {@link BinaryTree} to a {@link ConversionResult}\n * @param tree\t\tThe tree to convert\n * @param error\t\tOptional error message to include\n */\nfunction _treeToConverted(tree, error) {\n    var res = { error: error };\n    if (tree === null) {\n        res.value = tree;\n    }\n    else {\n        res.children = [\n            _treeToConverted(tree.left),\n            _treeToConverted(tree.right),\n        ];\n    }\n    return res;\n}\n/**\n * Shorthand method to build a {@link ConversionResult} from a {@link BinaryTree}\n * @param tree\t\tThe tree to convert\n * @param error\t\tOptional error message to include\n */\nfunction _treeToConversionResult(tree, error) {\n    return {\n        error: !!error,\n        tree: _treeToConverted(tree, error)\n    };\n}\n/**\n * Shorthand method to build a {@link ConversionResult} from a value\n * @param value\t\tThe value to convert\n * @param error\t\tOptional error message to include\n */\nfunction _valueToConversionResult(value, error) {\n    return {\n        error: !!error,\n        tree: { value: value, error: error }\n    };\n}\n/**\n * Shorthand method to create a {@link ConversionResult} from two child {@link ConversionResult}s\n * @param left\t\tLeft-hand child result\n * @param right\t\tLeft-hand child result\n * @param error\t\tOptional error message to include\n */\nfunction _parentConversionResult(left, right, error) {\n    return {\n        tree: {\n            error: error,\n            children: [left.tree, right.tree]\n        },\n        error: left.error || right.error || !!error,\n    };\n}\n//========\n//Internal converters\n//========\n/**\n * Convert each element of a list using a conversion tree's 'list' node.\n * @param tree\t\t\t\tThe tree to convert\n * @param conversionTree\tThe conversion tree node\n * @param atoms\t\t\t\tMap of custom language atoms\n */\nfunction _convertListInternal(tree, conversionTree, atoms) {\n    //Null trees match with empty lists\n    if (tree === null) {\n        return {\n            children: [],\n        };\n    }\n    //Convert the head element\n    var head = _convert(tree.left, conversionTree.type, atoms);\n    //Convert the rest of the list\n    var tail = _convertListInternal(tree.right, conversionTree, atoms);\n    //Add each element to the child nodes of the resulting tree\n    var children = [head.tree];\n    for (var _i = 0, _a = tail.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        children.push(child);\n    }\n    //Return the element(s)\n    return {\n        children: children,\n        error: head.error || tail.error\n    };\n}\n//========\n// Atom Types\n//========\n/**\n * Converts a binary tree to the 'false' value\n * @param tree\tThe tree to convert\n */\nfunction _convertFalse(tree) {\n    if (tree === null)\n        return _valueToConversionResult('false');\n    return _treeToConversionResult(tree, \"Expected 'false'\");\n}\n/**\n * Converts a binary tree to the 'true' value\n * @param tree\tThe tree to convert\n */\nfunction _convertTrue(tree) {\n    if (tree && tree.left === null && tree.right === null)\n        return _valueToConversionResult('true');\n    return _treeToConversionResult(tree, \"Expected 'true'\");\n}\n/**\n * Converts a binary tree to a boolean\n * @param tree\tThe tree to convert\n */\nfunction _convertBoolean(tree) {\n    //Check to see if the tree is 'false' first\n    var res = _convertFalse(tree);\n    if (!res.error)\n        return res;\n    //Then check to see if it is 'true'\n    res = _convertTrue(tree);\n    if (!res.error)\n        return res;\n    //Otherwise error - not a boolean\n    return _treeToConversionResult(tree, \"Expected 'true' or 'false'\");\n}\n/**\n * Converts a binary tree to an integer, optionally comparing with a specific integer\n * @param tree\t\tThe tree to convert\n * @param expected\tThe number to expect the tree to equal, or {@code undefined}\n */\nfunction _convertNumber(tree, expected) {\n    //Attempt to convert the tree to a number\n    var value = _readNumber(tree);\n    //Error if the tree doesn't represent a number\n    if (value === undefined) {\n        var error = \"Not a valid number\";\n        if (expected !== undefined)\n            error += \", expected \" + expected;\n        return _treeToConversionResult(tree, error);\n    }\n    //Error if the value is unexpected\n    if (expected !== undefined && value !== expected) {\n        return _valueToConversionResult(value, \"Expected \" + expected);\n    }\n    //Return the number tree\n    return _valueToConversionResult(value);\n}\n/**\n * Convert a tree using an atom string (e.g. 'nil'/'any'/'int')\n * @param tree\t\tThe tree to check\n * @param atom\t\tThe atomic string to check against\n * @param atoms\t\tMap of custom language atoms\n */\nfunction _convertAtom(tree, atom, atoms) {\n    //Built-in types\n    switch (atom) {\n        case 'nil':\n            //The tree node must be null\n            if (tree === null)\n                return _treeToConversionResult(tree);\n            return _treeToConversionResult(tree, \"Expected nil\");\n        case 'any':\n            //Any tree is valid\n            return { tree: _treeToConverted(tree) };\n        case 'int':\n            return _convertNumber(tree);\n        case 'false':\n            return _convertFalse(tree);\n        case 'true':\n            return _convertTrue(tree);\n        case 'bool':\n        case 'boolean':\n            return _convertBoolean(tree);\n    }\n    //Check if the atom has been defined by the user\n    var atomTree = atoms.get(atom);\n    //Can't check against unknown types\n    if (atomTree === undefined)\n        return _treeToConversionResult(tree, \"Unknown type '\" + atom + \"'\");\n    //Convert using the atom\n    var conversionResult = _convert(tree, atomTree, atoms);\n    //Add the atom name to the root of the subtree\n    conversionResult.tree.value = atom;\n    //Return the converted tree\n    return conversionResult;\n}\n//========\n// Converters\n//========\n/**\n * Convert the tree using a conversion tree 'choice' node\n * @param tree\t\t\t\tThe tree to check\n * @param conversionTree\tThe conversion tree node\n * @param atoms\t\t\t\tMap of custom language atoms\n */\nfunction _convertChoice(tree, conversionTree, atoms) {\n    var res;\n    //Test the tree against each type of the choice, in order\n    for (var _i = 0, _a = conversionTree.type; _i < _a.length; _i++) {\n        var type = _a[_i];\n        if (typeof type === \"string\")\n            res = _convertAtom(tree, type, atoms);\n        else if (typeof type === \"number\")\n            res = _convertNumber(tree, type);\n        else\n            res = _convert(tree, type, atoms);\n        //Return the result if it was converted with no errors\n        if (!res.error)\n            return res;\n    }\n    //If there is only one type in the choice, use that error\n    if (conversionTree.type.length === 1)\n        return res;\n    //Otherwise use a generic message\n    return _treeToConversionResult(tree, \"Node does not match any type of '\" + conversionTree.type.join(\"', '\") + \"'\");\n}\n/**\n * Convert the tree using a conversion tree 'tree' node\n * @param tree\t\t\t\tThe tree to check\n * @param conversionTree\tThe conversion tree node\n * @param atoms\t\t\t\tMap of custom language atoms\n */\nfunction _convertTree(tree, conversionTree, atoms) {\n    //An empty tree can't match a TreeType node\n    if (tree == null)\n        return _treeToConversionResult(tree, \"Expected a tree, got nil\");\n    //Convert the left and right nodes\n    return _parentConversionResult(_convert(tree.left, conversionTree.left, atoms), _convert(tree.right, conversionTree.right, atoms));\n}\n/**\n * Convert the tree using a conversion tree 'list' node\n * @param tree\t\t\t\tThe tree to check\n * @param conversionTree\tThe conversion tree node\n * @param atoms\t\t\t\tMap of custom language atoms\n */\nfunction _convertList(tree, conversionTree, atoms) {\n    //Convert each element of the list\n    var res = _convertListInternal(tree, conversionTree, atoms);\n    //Wrap the elements in a tree structure\n    var children = res.children;\n    return {\n        error: res.error,\n        tree: {\n            children: children,\n            value: '[]',\n            list: true\n        }\n    };\n}\n//========\n// General\n//========\n/**\n * Read the type of the conversion tree's root node, and convert the tree accordingly\n * @param tree\t\t\t\tThe tree to check\n * @param conversionTree\tThe conversion tree node\n * @param atoms\t\t\t\tMap of custom language atoms\n */\nfunction _convert(tree, conversionTree, atoms) {\n    var category = conversionTree.category;\n    switch (category) {\n        case \"choice\":\n            return _convertChoice(tree, conversionTree, atoms);\n        case \"list\":\n            return _convertList(tree, conversionTree, atoms);\n        case \"tree\":\n            return _convertTree(tree, conversionTree, atoms);\n        default:\n            throw new ConverterException_1.default(\"Unknown branch type: '\" + category + \"'\");\n    }\n}\n/**\n * Match a binary tree against a given conversion tree\n * @param tree\t\t\t\tThe tree to convert\n * @param conversionTree\tThe conversion tree to use (should be generated by the `parser`)\n * @param atoms\t\t\t\tMap of custom atomic values to extend the language.\n * \t\t\t\t\t\t\tRepresented in {@code atomName:ConversionTree} format.\n * @returns\t\tAn object containing the result of the conversion,\n * \t\t\t\tand a boolean saying if there is an error anywhere in the tree\n */\nfunction runConvert(tree, conversionTree, atoms) {\n    atoms = atoms || new Map();\n    //Perform the tree conversion\n    var res = _convert(tree, conversionTree, atoms);\n    //Return the type, ensuring `error` is always a boolean\n    return {\n        tree: res.tree,\n        error: !!res.error,\n    };\n}\nexports.default = runConvert;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.displayProgram = exports.displayPad = exports.fromPad = exports.toPad = exports.MacroManager = exports.ProgramManager = exports.Interpreter = exports.parseProgram = exports.linter = void 0;\nvar tslib_1 = require(\"tslib\");\nvar linter_1 = tslib_1.__importStar(require(\"./linter\"));\nexports.linter = linter_1.default;\nObject.defineProperty(exports, \"parseProgram\", { enumerable: true, get: function () { return linter_1.parseProgram; } });\nvar Interpreter_1 = tslib_1.__importDefault(require(\"./run/Interpreter\"));\nexports.Interpreter = Interpreter_1.default;\nvar ProgramManager_1 = tslib_1.__importDefault(require(\"./utils/ProgramManager\"));\nexports.ProgramManager = ProgramManager_1.default;\nvar MacroManager_1 = tslib_1.__importDefault(require(\"./utils/MacroManager\"));\nexports.MacroManager = MacroManager_1.default;\nvar progAsData_1 = tslib_1.__importStar(require(\"./tools/progAsData\"));\nObject.defineProperty(exports, \"toPad\", { enumerable: true, get: function () { return progAsData_1.default; } });\nObject.defineProperty(exports, \"displayPad\", { enumerable: true, get: function () { return progAsData_1.displayPad; } });\nObject.defineProperty(exports, \"fromPad\", { enumerable: true, get: function () { return progAsData_1.fromPad; } });\nvar displayProg_1 = tslib_1.__importDefault(require(\"./tools/displayProg\"));\nexports.displayProgram = displayProg_1.default;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ConverterException = /** @class */ (function (_super) {\n    __extends(ConverterException, _super);\n    function ConverterException(message) {\n        return _super.call(this, message) || this;\n    }\n    return ConverterException;\n}(Error));\nexports.default = ConverterException;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StringBuilder = void 0;\nvar tslib_1 = require(\"tslib\");\n/**\n * Utility class to simplify creating strings for output.\n */\nvar StringBuilder = /** @class */ (function () {\n    function StringBuilder(props) {\n        if (props === void 0) { props = {}; }\n        this._level = 0;\n        this._lines = [[0, '']];\n        this._props = {\n            indent: (props.indent !== undefined) ? props.indent : '    ',\n            linebreak: (props.linebreak !== undefined) ? props.linebreak : '\\n',\n        };\n    }\n    /**\n     * Indent the current line.\n     * @returns this\tFor chaining operations\n     */\n    StringBuilder.prototype.indent = function () {\n        //Indent the current line, and save for future lines\n        this._lines[this._lines.length - 1][0] = ++this._level;\n        return this;\n    };\n    /**\n     *Remove an indentation level from the current line.\n     * @returns this\tFor chaining operations\n     */\n    StringBuilder.prototype.dedent = function () {\n        if (this._level > 0)\n            this._level--;\n        this._lines[this._lines.length - 1][0] = this._level;\n        return this;\n    };\n    /**\n     * Add a new line to the end of the string\n     * @param line\t\tThe line to add\n     * @returns this\tFor chaining operations\n     */\n    StringBuilder.prototype.push = function (line) {\n        this._lines.push([this._level, line.toString()]);\n        return this;\n    };\n    /**\n     * Add some text to the end of the current line\n     * @param text\t\tThe text to add\n     * @returns this\tFor chaining operations\n     */\n    StringBuilder.prototype.add = function (text) {\n        this._lines[this._lines.length - 1][1] += text;\n        return this;\n    };\n    /**\n     * Add a new empty line to the end of the string\n     * @returns this\tFor chaining operations\n     */\n    StringBuilder.prototype.break = function () {\n        this._lines.push([this._level, '']);\n        return this;\n    };\n    StringBuilder.prototype.toString = function () {\n        var _this = this;\n        return this._lines.map(function (_a) {\n            var _b = tslib_1.__read(_a, 2), i = _b[0], t = _b[1];\n            return _this.props.indent.repeat(i) + t;\n        }).join(this.props.linebreak);\n    };\n    Object.defineProperty(StringBuilder.prototype, \"level\", {\n        get: function () {\n            return this._level;\n        },\n        set: function (value) {\n            this._level = value;\n            this._lines[this._lines.length - 1][0] = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StringBuilder.prototype, \"props\", {\n        get: function () {\n            return this._props;\n        },\n        set: function (value) {\n            this._props = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StringBuilder.prototype, \"lines\", {\n        get: function () {\n            return this._lines;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return StringBuilder;\n}());\nexports.StringBuilder = StringBuilder;\n//# sourceMappingURL=StringBuilder.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar position_1 = require(\"../../types/position\");\nvar errorManager_1 = require(\"../../utils/errorManager\");\nvar tokens_1 = require(\"../../types/tokens\");\nvar extendedTokens_1 = require(\"../../types/extendedTokens\");\nvar SYMBOL_LIST = [\n    //Symbols\n    tokens_1.TKN_SEP,\n    tokens_1.TKN_ASSGN,\n    tokens_1.TKN_BLOCK_OPN, tokens_1.TKN_BLOCK_CLS,\n    tokens_1.TKN_PREN_OPN, tokens_1.TKN_PREN_CLS,\n];\nvar EXPR_LIST = [\n    //Expression tokens\n    tokens_1.TKN_READ, tokens_1.TKN_WRITE,\n    tokens_1.TKN_IF, tokens_1.TKN_ELSE,\n    tokens_1.TKN_WHILE,\n];\nvar OP_LIST = [\n    //Operations\n    tokens_1.TKN_CONS,\n    tokens_1.TKN_HD, tokens_1.TKN_TL,\n];\nvar SYMBOL_LIST_EXTD = tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(SYMBOL_LIST)), [\n    extendedTokens_1.TKN_EQL,\n    extendedTokens_1.TKN_COMMA,\n    extendedTokens_1.TKN_DOT,\n    extendedTokens_1.TKN_COLON,\n    extendedTokens_1.TKN_MCRO_OPN, extendedTokens_1.TKN_MCRO_CLS,\n    extendedTokens_1.TKN_LIST_OPN, extendedTokens_1.TKN_LIST_CLS,\n]);\nvar EXPR_LIST_EXTD = tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(EXPR_LIST)), [\n    extendedTokens_1.TKN_SWITCH,\n    extendedTokens_1.TKN_CASE,\n    extendedTokens_1.TKN_DEFAULT,\n]);\nvar OP_LIST_EXTD = tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(OP_LIST)), [\n    extendedTokens_1.TKN_TRUE,\n    extendedTokens_1.TKN_FALSE,\n]);\n/**\n * Read an identifier (variable/program name) from the start of the program string.\n * Identifiers match the regex {@code /[a-z_]\\w*\\/i}\n * @param program\tThe program string\n */\nfunction read_identifier(program) {\n    //Read the longest identifier possible from the program string\n    //Case insensitive, starts with a letter or underscore, optionally followed by any number of alphanumeric chars and underscores\n    var exec = /^[a-z_]\\w*/i.exec(program);\n    if (exec === null)\n        return null;\n    return exec[0];\n}\n/**\n * Read a number from the start of the program string.\n * @param program\tThe program string\n */\nfunction read_number(program) {\n    //Read the longest number possible from the program string\n    //Must not be followed by an identifier character afterwards (e.g. `0a` or `0_2` as this is an invalid identifier)\n    var exec = /^(\\d+)[^\\w]*/.exec(program);\n    if (exec === null)\n        return null;\n    return exec[1];\n}\n/**\n * Read a programs-as-data token from the start of the program string\n * @param program\tthe program string\n */\nfunction read_pad_token(program) {\n    var token = program.match(/^(@[:=a-z]+)/i);\n    if (token === null)\n        return null;\n    return token[0];\n}\n/**\n * Read a token from the start of the program string\n * @param program\tThe program string\n * @param pos\t\tThe position counter\n * @param pureOnly\tWhether to only accept tokens used in the pure language\n * @returns WHILE_TOKEN\t\t\tIf {@code pureOnly} is {@code true}\n * @returns WHILE_TOKEN_EXTD\tIf {@code pureOnly} is {@code false}\n * @returns null\tIf the next token is not a valid symbol or identifier name\n */\nfunction read_next_token(program, pos, pureOnly) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    if (pureOnly === void 0) { pureOnly = false; }\n    try {\n        //Attempt to read a symbol\n        for (var _d = tslib_1.__values(pureOnly ? SYMBOL_LIST : SYMBOL_LIST_EXTD), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var sym = _e.value;\n            //Check each symbol against the start of the program string\n            if (program.substr(0, sym.length) === sym) {\n                var endPos = tslib_1.__assign({}, pos);\n                position_1.incrementPos(endPos, sym);\n                //Return the symbol token if a match is found\n                return {\n                    type: 'symbol',\n                    value: sym,\n                    pos: pos,\n                    endPos: endPos,\n                    length: sym.length,\n                };\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    //Attempt to read an identifier\n    //E.g. program/variable name, operator\n    var expr = read_identifier(program);\n    if (expr === null) {\n        if (pureOnly)\n            return null;\n        //Attempt to read a programs-as-data token\n        expr = read_pad_token(program);\n        if (expr !== null) {\n            return {\n                type: 'number',\n                token: expr,\n                value: extendedTokens_1.PAD_VALUES[expr],\n                length: expr.length,\n                pos: pos,\n                endPos: {\n                    row: pos.row,\n                    col: pos.col + expr.length,\n                },\n            };\n        }\n        //Attempt to read a number instead\n        expr = read_number(program);\n        if (expr === null)\n            return null;\n        return {\n            type: 'number',\n            token: expr,\n            value: Number.parseInt(expr),\n            length: expr.length,\n            pos: pos,\n            endPos: {\n                row: pos.row,\n                col: pos.col + expr.length,\n            },\n        };\n    }\n    try {\n        //See if the identifier is a known value\n        for (var _f = tslib_1.__values(pureOnly ? EXPR_LIST : EXPR_LIST_EXTD), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var tkn = _g.value;\n            if (expr === tkn) {\n                var endPos = tslib_1.__assign({}, pos);\n                position_1.incrementPos(endPos, tkn);\n                return {\n                    type: 'expression',\n                    value: tkn,\n                    length: tkn.length,\n                    pos: pos,\n                    endPos: endPos,\n                };\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    try {\n        for (var _h = tslib_1.__values(pureOnly ? OP_LIST : OP_LIST_EXTD), _j = _h.next(); !_j.done; _j = _h.next()) {\n            var tkn = _j.value;\n            if (expr === tkn) {\n                var endPos = tslib_1.__assign({}, pos);\n                position_1.incrementPos(endPos, tkn);\n                return {\n                    type: 'operation',\n                    value: tkn,\n                    length: tkn.length,\n                    pos: pos,\n                    endPos: endPos,\n                };\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    //Otherwise the token is an identifier name\n    return {\n        type: 'identifier',\n        value: expr,\n        length: expr.length,\n        pos: pos,\n        endPos: {\n            row: pos.row,\n            col: pos.col + expr.length\n        },\n    };\n}\n/**\n * Lex a program string into a list of tokens\n * @param program\tThe program to lex\n * @param props\t\tConfiguration options for the lexer\n */\nfunction lexer(program, props) {\n    var errorManager = new errorManager_1.ErrorManager();\n    props = props || {};\n    var options = {\n        pureOny: props.pureOnly || false\n    };\n    //Maintain a counter of how many characters have been processed\n    var pos = { row: 0, col: 0 };\n    //Hold the produced token list\n    var res = [];\n    //Run until the input string is empty\n    while (program.length) {\n        var whitespace = program.match(/^\\s+/);\n        if (whitespace !== null) {\n            var match = whitespace[0];\n            position_1.incrementPos(pos, match);\n            program = program.substring(match.length);\n            continue;\n        }\n        //End-of-line comment\n        if (program.substr(0, 2) === '//') {\n            //Ignore text to the next line break, or the end of the program\n            var index = program.search('\\n') || -1;\n            //Go to the end of the string\n            if (index === -1)\n                index = program.length;\n            //Go to the end of the line, plus the line break\n            else\n                index += 1;\n            pos.row++;\n            pos.col = 0;\n            program = program.substring(index);\n            continue;\n        }\n        //Comment block (multiline/inline)\n        if (program.substr(0, 2) == '(*') {\n            //Ignore text to the end of the comment block\n            var index = program.search(/\\*\\)/) || -1;\n            index = index === -1 ? program.length : index + 2;\n            position_1.incrementPos(pos, program.substring(0, index));\n            program = program.substring(index);\n            continue;\n        }\n        //Read the next token in the program\n        var token = read_next_token(program, tslib_1.__assign({}, pos), options.pureOny);\n        if (token === null) {\n            //Return the first character from the program string\n            var next = program.charAt(0);\n            //Mark unrecognised tokens\n            token = {\n                type: 'unknown',\n                value: next,\n                pos: tslib_1.__assign({}, pos),\n                endPos: {\n                    row: pos.row,\n                    col: pos.col + next.length,\n                },\n                length: next.length,\n            };\n            //Add an error at the current position\n            errorManager.addError(pos, \"Unknown token \\\"\" + next + \"\\\"\", token.endPos);\n        }\n        //Save the token to the list\n        res.push(token);\n        //Remove the token from the start of the program\n        if (token.type === 'number')\n            pos.col += token.length;\n        else\n            position_1.incrementPos(pos, token.value);\n        program = program.substring(token.length);\n    }\n    //Return the produced token list and any created errors\n    return [res, errorManager.errors,];\n}\nexports.default = lexer;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TKN_TL = exports.TKN_HD = exports.TKN_CONS = exports.TKN_WRITE = exports.TKN_READ = exports.TKN_WHILE = exports.TKN_ELSE = exports.TKN_IF = exports.TKN_PREN_CLS = exports.TKN_PREN_OPN = exports.TKN_BLOCK_CLS = exports.TKN_BLOCK_OPN = exports.TKN_ASSGN = exports.TKN_SEP = void 0;\nexports.TKN_SEP = ';';\nexports.TKN_ASSGN = ':=';\nexports.TKN_BLOCK_OPN = '{';\nexports.TKN_BLOCK_CLS = '}';\nexports.TKN_PREN_OPN = '(';\nexports.TKN_PREN_CLS = ')';\nexports.TKN_IF = 'if';\nexports.TKN_ELSE = 'else';\nexports.TKN_WHILE = 'while';\nexports.TKN_READ = 'read';\nexports.TKN_WRITE = 'write';\nexports.TKN_CONS = 'cons';\nexports.TKN_HD = 'hd';\nexports.TKN_TL = 'tl';\n//# sourceMappingURL=tokens.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar VariableManager_1 = tslib_1.__importDefault(require(\"./VariableManager\"));\nvar NameGenerator_1 = tslib_1.__importDefault(require(\"./NameGenerator\"));\nvar astEquals_1 = tslib_1.__importDefault(require(\"../tools/astEquals\"));\nvar displayProg_1 = tslib_1.__importDefault(require(\"../tools/displayProg\"));\nvar progAsData_1 = tslib_1.__importStar(require(\"../tools/progAsData\"));\n/**\n * Reverse a list, and add it to the end of a stack.\n * Useful for ordered DFS traversal of an AST (for e.g. ordered variable renaming).\n * @param stack\t\tThe stack\n * @param body\t\tThe list of data to add\n */\nfunction _pushBodyToStack(stack, body) {\n    for (var i = body.length - 1; i >= 0; --i) {\n        stack.push(body[i]);\n    }\n}\n/**\n * Class to perform operations on a program AST.\n */\nvar ProgramManager = /** @class */ (function () {\n    /**\n     * @param prog\t\tThe program AST\n     * @param props\t\tAdditional constructor options\n     */\n    function ProgramManager(prog, props) {\n        this._props = props || {};\n        this._prog = prog;\n        this._variableManager = new VariableManager_1.default();\n        this._variablePositions = new Map();\n        this._macros = new Map();\n        this._macroPositions = new Map();\n        this.reanalyse();\n    }\n    /**\n     * Create a ProgramManager object from a program-as-data object\n     * @param data\t\tThe PaD object representing a program\n     * @param props\t\t(Optional) program manager construction options to use when creating the ProgramManager\n     */\n    ProgramManager.fromPad = function (data, props) {\n        return new ProgramManager(progAsData_1.fromPad(data), props);\n    };\n    Object.defineProperty(ProgramManager.prototype, \"variableManager\", {\n        /**\n         * Get the variable manager representing the program in its current state\n         */\n        get: function () {\n            return this._variableManager;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ProgramManager.prototype, \"variables\", {\n        get: function () {\n            return this.variableManager.variables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ProgramManager.prototype, \"macros\", {\n        /**\n         * Get a list of all the macros in the program\n         * @returns {string[]}\tList of the names of each macro referenced in the program\n         */\n        get: function () {\n            return Array.from(this._macros.keys());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ProgramManager.prototype, \"macroCounts\", {\n        /**\n         * Get a list of all the macros in the program, and the number of occurrences of each\n         * @returns {[string, number][]}\tList where each macro is of the format [macroName, occurrenceCount]\n         */\n        get: function () {\n            return new Map(this._macros.entries());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ProgramManager.prototype, \"prog\", {\n        /**\n         * Get the program being managed by this object\n         */\n        get: function () {\n            return this._prog;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Change the program being managed by this object.\n     * {@link this.reanalyse} is called automatically.\n     * @param prog\tThe new program to manage.\n     */\n    ProgramManager.prototype.setProg = function (prog) {\n        this._prog = prog;\n        this.reanalyse();\n    };\n    /**\n     * Manually trigger a refresh of the program state.\n     * Useful if the AST object has been updated.\n     */\n    ProgramManager.prototype.reanalyse = function () {\n        this._variableManager = new VariableManager_1.default();\n        this._macros = new Map();\n        this._macroPositions = new Map();\n        this._variablePositions = new Map();\n        this._analyseProgram();\n    };\n    /**\n     * Replace the first occurrence of a macro call with the code from its program.\n     * @param macro\t\t\t\tThe AST to replace the macro call with\n     * @param name\t\t\t\t(Optional) The name of the macro to replace.\n     * \t\t\t\t\t\t\tDefaults to {@code macro.name.value}\n     * @param convertToPure\t\tWhether to convert the macro to pure WHILE before inserting it\n     */\n    ProgramManager.prototype.replaceMacro = function (macro, name, convertToPure) {\n        var e_1, _a, _b;\n        if (convertToPure === void 0) { convertToPure = false; }\n        //Use the macro name as the variable namespace, unless the namespace already exists\n        var namespace = this.variableManager.namespaceExists(macro.name.value)\n            ? this.variableManager.getNewNamespace()\n            : macro.name.value;\n        //TODO: Allow refactoring macros other than the first in the list\n        var macroPositions = this._macroPositions.get(name || macro.name.value);\n        if (!macroPositions)\n            return;\n        var macroPosition = macroPositions[0];\n        //Macro expression is of type AST_MACRO here, but needs to be declared as type `any` so it can be changed to `AST_IDENT_NAME` after the refactor\n        var macroExpr = macroPosition.expr;\n        var macroManager = new ProgramManager(macro);\n        //Convert the macro to pure WHILE if requested\n        if (convertToPure)\n            macroManager.toPure();\n        try {\n            for (var _c = tslib_1.__values(macroManager.variables), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var v = _d.value;\n                var newName = this.variableManager.add(v, namespace);\n                macroManager.renameVariable(v, newName);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        //Expression to assign the macro input to a variable\n        var pre = {\n            type: 'assign',\n            complete: true,\n            ident: { type: 'identName', value: macro.input.value },\n            arg: macroExpr.input,\n        };\n        //Insert the macro code into the program body directly before the macro call expression\n        var index = macroPosition.parent_body.indexOf(macroPosition.parent_cmd);\n        (_b = macroPosition.parent_body).splice.apply(_b, tslib_1.__spreadArray([index, 0, pre], tslib_1.__read(macro.body)));\n        //Set/remove the properties to convert from an AST_MACRO to an AST_IDENT_NAME\n        delete macroExpr.program;\n        delete macroExpr.input;\n        delete macroExpr.complete;\n        macroExpr.type = 'identName';\n        macroExpr.value = macro.output.value;\n        this.reanalyse();\n    };\n    /**\n     * Rename all occurrences of a variable in the program\n     * @param oldname\tThe old (current) name of the variable\n     * @param newname\tThe new name of the variable\n     */\n    ProgramManager.prototype.renameVariable = function (oldname, newname) {\n        //Get all the positions where the variable is referenced\n        var positions = this._variablePositions.get(oldname);\n        if (positions === undefined)\n            return;\n        //Rename the variable at all points\n        positions.forEach(function (p) { return p.value = newname; });\n        //Remove the old name from the variable manager and add under the new name\n        this.variableManager.delete(oldname);\n        this.variableManager.add(newname);\n        //Remove the positions from the old name to the new name\n        this._variablePositions.delete(oldname);\n        var newpos = this._variablePositions.get(newname) || [];\n        newpos.push.apply(newpos, tslib_1.__spreadArray([], tslib_1.__read(positions)));\n        this._variablePositions.set(newname, newpos);\n    };\n    /**\n     * Produce a program string from the stored program AST\n     * @param indent\tThe character(s) to use to indicate a single indent.\n     * \t\t\t\t\tDefaults to {@code '\\t'} (a tab character).\n     */\n    ProgramManager.prototype.displayProgram = function (indent) {\n        if (indent === void 0) { indent = '\\t'; }\n        return displayProg_1.default(this.prog, indent);\n    };\n    /**\n     * Traverse the AST, collecting information about the program.\n     * @private\n     */\n    ProgramManager.prototype._analyseProgram = function () {\n        var e_2, _a;\n        //Save the program's input variable\n        this._analyseExpr(this._prog.input, this._prog, this._prog.body);\n        try {\n            //Iterate through the program body in order\n            for (var _b = tslib_1.__values(this._prog.body), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var cmd = _c.value;\n                this._analyseCmd(cmd, this._prog.body);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        //Save the program's output variable\n        this._analyseExpr(this._prog.output, this._prog, this._prog.body);\n        return this;\n    };\n    /**\n     * Traverse a {@code AST_CMD}, collecting information about the program.\n     * Part of {@link this._analyseProgram}.\n     * @param cmd\t\t\tThe command to traverse.\n     * @param parentBody\tThe code \"body\" (list of commands) containing this command.\n     * \t\t\t\t\t\tFor use with {@link this._macroPositions}\n     * @private\n     */\n    ProgramManager.prototype._analyseCmd = function (cmd, parentBody) {\n        var e_3, _a;\n        //Add the command to the stack\n        var stack = [cmd];\n        while (stack.length > 0) {\n            //Get the next command from the top of the stack\n            var cmd_1 = stack.pop();\n            switch (cmd_1.type) {\n                case \"assign\":\n                    //Save the assigning variable\n                    this._analyseExpr(cmd_1.ident, cmd_1, parentBody);\n                    //Analyse the assignee expression\n                    this._analyseExpr(cmd_1.arg, cmd_1, parentBody);\n                    break;\n                case \"cond\":\n                    //Analyse the condition's expression\n                    this._analyseExpr(cmd_1.condition, cmd_1, parentBody);\n                    //Traverse the truthy body, then the falsy body\n                    _pushBodyToStack(stack, cmd_1.else);\n                    _pushBodyToStack(stack, cmd_1.if);\n                    break;\n                case \"loop\":\n                    //Analyse the loop's condition expression\n                    this._analyseExpr(cmd_1.condition, cmd_1, parentBody);\n                    //Traverse the loop's body\n                    _pushBodyToStack(stack, cmd_1.body);\n                    break;\n                case \"switch\":\n                    //Analyse the loop's condition expression\n                    this._analyseExpr(cmd_1.condition, cmd_1, parentBody);\n                    try {\n                        //Analyse the condition and body of each case statement\n                        for (var _b = (e_3 = void 0, tslib_1.__values(cmd_1.cases)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                            var c = _c.value;\n                            this._analyseExpr(c.cond, cmd_1, parentBody);\n                            _pushBodyToStack(stack, c.body);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                    break;\n            }\n        }\n    };\n    /**\n     * Traverse a {@code AST_EXPR}, collecting information about the program.\n     * Part of {@link this._analyseProgram}.\n     * @param expr\t\t\tThe expression to traverse.\n     * @param parentCommand\tThe command which contains this expression.\n     * \t\t\t\t\t\tFor use with {@link this._macroPositions} and {@link this._variablePositions}.\n     * @param parentBody\tThe code \"body\" (list of commands) containing {@code parentCommand}.\n     * \t\t\t\t\t\tFor use with {@link this._macroPositions}\n     * @private\n     */\n    ProgramManager.prototype._analyseExpr = function (expr, parentCommand, parentBody) {\n        var stack = [expr];\n        while (stack.length > 0) {\n            var expr_1 = stack.pop();\n            switch (expr_1.type) {\n                case \"identName\":\n                    //Save the variable name in the manager\n                    if (expr_1.value !== 'nil') {\n                        this._variableManager.add(expr_1.value, undefined, expr_1.value);\n                        var list = this._variablePositions.get(expr_1.value);\n                        if (list === undefined)\n                            this._variablePositions.set(expr_1.value, list = []);\n                        list.push(expr_1);\n                    }\n                    break;\n                case \"operation\":\n                    //Analyse each of the operation's arguments\n                    _pushBodyToStack(stack, expr_1.args);\n                    break;\n                case \"equal\":\n                    //Analyse the left argument, then the right argument\n                    stack.push(expr_1.arg2);\n                    stack.push(expr_1.arg1);\n                    break;\n                case \"list\":\n                    //Analyse each element of the list\n                    _pushBodyToStack(stack, expr_1.elements);\n                    break;\n                case \"tree_expr\":\n                    //Analyse the left-side of the tree, then the right side\n                    stack.push(expr_1.right);\n                    stack.push(expr_1.left);\n                    break;\n                case \"macro\":\n                    //Add the program macro to the store\n                    this._macros.set(expr_1.program, (this._macros.get(expr_1.program) || 0) + 1);\n                    var pos = this._macroPositions.get(expr_1.program);\n                    if (pos === undefined)\n                        this._macroPositions.set(expr_1.program, pos = []);\n                    pos.push({\n                        expr: expr_1,\n                        parent_body: parentBody,\n                        //Only variables can be assigned directly by an AST_PROG\n                        parent_cmd: parentCommand,\n                    });\n                    //Analyse the input expression to the macro\n                    stack.push(expr_1.input);\n                    break;\n                case \"tree\":\n                    //Nothing to analyse\n                    break;\n            }\n        }\n    };\n    /**\n     * Convert the program's AST to pure WHILE.\n     * The resulting AST will have the same semantics as the original program.\n     * @returns {this}\tThis ProgramManager object\n     */\n    ProgramManager.prototype.toPure = function (macros) {\n        var e_4, _a;\n        //Get a unique macro name to use for replacing the equals expressions in the code\n        var equalsMacroName;\n        var nameGenerator = new NameGenerator_1.default();\n        do {\n            equalsMacroName = nameGenerator.next();\n        } while (this.macroCounts.has(equalsMacroName));\n        try {\n            for (var _b = tslib_1.__values(macros || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var macro = _c.value;\n                var name_1 = void 0;\n                var prog = void 0;\n                if (macro.p) {\n                    var macro1 = macro;\n                    name_1 = macro1.n || macro1.p.name.value;\n                    prog = macro1.p;\n                }\n                else {\n                    prog = macro;\n                    name_1 = macro.name.value;\n                }\n                while (this.macros.includes(name_1))\n                    this.replaceMacro(prog, name_1, true);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        //Convert the program body to pure\n        this._bodyToPure(this._prog.body, equalsMacroName);\n        //Reanalyse the AST since the tree may have changed\n        this.reanalyse();\n        //Replace each of the equality macros with the actual code\n        while (this.macroCounts.has(equalsMacroName)) {\n            this.replaceMacro(astEquals_1.default, equalsMacroName);\n        }\n        //Return the manager\n        return this;\n    };\n    /**\n     * Convert an AST_BODY element to pure WHILE\n     * @param body\t\t\t\tThe body to convert\n     * @param equalsMacroName\tName of the macro replacing equals operations\n     * @private\n     */\n    ProgramManager.prototype._bodyToPure = function (body, equalsMacroName) {\n        var e_5, _a;\n        try {\n            for (var body_1 = tslib_1.__values(body), body_1_1 = body_1.next(); !body_1_1.done; body_1_1 = body_1.next()) {\n                var cmd = body_1_1.value;\n                this._cmdToPure(cmd, equalsMacroName);\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (body_1_1 && !body_1_1.done && (_a = body_1.return)) _a.call(body_1);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        return body;\n    };\n    /**\n     * Convert a `cmd` command to pure WHILE\n     * @param cmd\t\t\t\tThe cmd to convert\n     * @param equalsMacroName\tName of the macro replacing equals operations\n     * @private\n     */\n    ProgramManager.prototype._cmdToPure = function (cmd, equalsMacroName) {\n        var _this = this;\n        switch (cmd.type) {\n            case \"assign\":\n                cmd.arg = this._exprToPure(cmd.arg, equalsMacroName);\n                break;\n            case \"cond\":\n                cmd.condition = this._exprToPure(cmd.condition, equalsMacroName);\n                cmd.if = cmd.if.map(function (c) { return _this._cmdToPure(c, equalsMacroName); });\n                cmd.else = cmd.else.map(function (c) { return _this._cmdToPure(c, equalsMacroName); });\n                break;\n            case \"loop\":\n                cmd.condition = this._exprToPure(cmd.condition, equalsMacroName);\n                cmd.body = cmd.body.map(function (c) { return _this._cmdToPure(c, equalsMacroName); });\n                break;\n            case \"switch\":\n                this._switchToPure(cmd, equalsMacroName);\n                break;\n        }\n        return cmd;\n    };\n    /**\n     * Convert a `switch` command to pure WHILE\n     * @param sw\t\t\t\tThe switch to convert\n     * @param equalsMacroName\tName of the macro replacing equals operations\n     * @private\n     */\n    ProgramManager.prototype._switchToPure = function (sw, equalsMacroName) {\n        //Save the switch condition expression, and the cases and default block\n        var condition = sw.condition;\n        var cases = sw.cases;\n        var dflt = sw.default;\n        //Restructure the switch object into an IF statement\n        var root = sw;\n        root.type = 'cond';\n        root.else = [];\n        delete root.cases;\n        delete root.default;\n        delete root.condition;\n        if (cases.length === 0) {\n            //If there are no cases, all cases should fall into the \"default\" block\n            //TODO: Is it possible to remove `if nil` condition and just return the code body?\n            root.condition = { type: 'tree', complete: true, tree: null };\n            root.if = [];\n        }\n        else {\n            //Otherwise, the root condition should be comparing the switch's input\n            //with the first case's condition\n            root.condition = this._exprToPure({\n                type: 'equal',\n                complete: true,\n                arg1: condition,\n                arg2: cases[0].cond,\n            }, equalsMacroName);\n            root.if = this._bodyToPure(cases[0].body, equalsMacroName);\n        }\n        //Travel through the switch adding each case to the last condition's else block\n        //The first case is skipped because it has already been set to the root (if it exists)\n        var prevIf = root;\n        for (var i = 1; i < cases.length; i++) {\n            var c = cases[i];\n            //The if statement for this case\n            var cond = {\n                type: 'cond',\n                complete: true,\n                //Compare the condition with the switch's input expression\n                condition: this._exprToPure({\n                    type: 'equal',\n                    complete: true,\n                    arg1: condition,\n                    arg2: c.cond,\n                }, equalsMacroName),\n                //Case body goes here\n                if: this._bodyToPure(c.body, equalsMacroName),\n                //Else statement to be populated with the next case, or the default statement\n                else: [],\n            };\n            //Add this condition to the previous if's else block\n            prevIf.else.push(cond);\n            //Save this if statement to be accessed as the next condition's parent\n            prevIf = cond;\n        }\n        //Set the final else block to the default case's body\n        prevIf.else = this._bodyToPure(dflt.body, equalsMacroName);\n        //Return the root condition\n        return root;\n    };\n    /**\n     * Convert a `list` command to pure WHILE\n     * @param lst\t\t\t\tThe list to convert\n     * @param equalsMacroName\tName of the macro replacing equals operations\n     * @private\n     */\n    ProgramManager.prototype._listToPure = function (lst, equalsMacroName) {\n        var res = { type: 'tree', complete: true, tree: null };\n        for (var i = lst.elements.length - 1; i >= 0; --i) {\n            res = {\n                type: 'operation',\n                complete: true,\n                op: { type: 'opToken', value: 'cons' },\n                args: [\n                    this._exprToPure(lst.elements[i], equalsMacroName),\n                    res\n                ],\n            };\n        }\n        return res;\n    };\n    /**\n     * Convert a `expr` command to pure WHILE\n     * @param expr\t\t\t\tThe expr to convert\n     * @param equalsMacroName\tName of the macro replacing equals operations\n     * @private\n     */\n    ProgramManager.prototype._exprToPure = function (expr, equalsMacroName) {\n        switch (expr.type) {\n            case \"identName\":\n                break;\n            case \"operation\":\n                for (var i = 0; i < expr.args.length; i++) {\n                    expr.args[i] = this._exprToPure(expr.args[i], equalsMacroName);\n                }\n                break;\n            case \"equal\":\n                return {\n                    type: 'macro',\n                    complete: true,\n                    program: equalsMacroName,\n                    input: {\n                        type: 'operation',\n                        complete: true,\n                        op: { type: 'opToken', value: 'cons' },\n                        args: [this._exprToPure(expr.arg1, equalsMacroName), this._exprToPure(expr.arg2, equalsMacroName)]\n                    },\n                };\n            case \"list\":\n                return this._listToPure(expr, equalsMacroName);\n            case \"tree_expr\":\n                return this._treeExprToPure(expr, equalsMacroName);\n            case \"tree\":\n                return this._treeToPure(expr.tree);\n            case \"macro\":\n                expr.input = this._exprToPure(expr.input, equalsMacroName);\n                break;\n        }\n        return expr;\n    };\n    /**\n     * Convert a `treeExpr` command to pure WHILE\n     * @param tree\tThe treeExpr to convert\n     * @param equalsMacroName\tName of the macro replacing equals operations\n     * @private\n     */\n    ProgramManager.prototype._treeExprToPure = function (tree, equalsMacroName) {\n        return {\n            type: 'operation',\n            complete: true,\n            op: { type: 'opToken', value: 'cons' },\n            args: [\n                this._exprToPure(tree.left, equalsMacroName),\n                this._exprToPure(tree.right, equalsMacroName),\n            ],\n        };\n    };\n    /**\n     * Convert a binary tree to pure WHILE\n     * @param tree\tThe tree to convert\n     * @private\n     */\n    ProgramManager.prototype._treeToPure = function (tree) {\n        function nil() {\n            return {\n                type: 'tree',\n                complete: true,\n                tree: null\n            };\n        }\n        if (tree === null)\n            return nil();\n        var treeStack = [];\n        var opStack = [];\n        treeStack.push(tree);\n        var root = {\n            type: 'operation',\n            complete: true,\n            op: { type: 'opToken', value: 'cons' },\n            args: [],\n        };\n        opStack.push(root);\n        function _addChildTree(subtree, op, opStack, treeStack) {\n            if (subtree === null) {\n                op.args.push(nil());\n                return;\n            }\n            var child = {\n                type: 'operation',\n                complete: true,\n                op: { type: 'opToken', value: 'cons' },\n                args: [],\n            };\n            op.args.push(child);\n            opStack.push(child);\n            treeStack.push(subtree);\n        }\n        while (opStack.length > 0) {\n            var tree_1 = treeStack.pop();\n            var op = opStack.pop();\n            if (op.args.length === 0) {\n                treeStack.push(tree_1);\n                opStack.push(op);\n                _addChildTree(tree_1.left, op, opStack, treeStack);\n            }\n            else if (op.args.length === 1) {\n                _addChildTree(tree_1.right, op, opStack, treeStack);\n            }\n            else {\n                //This subtree is finished\n                //Keep going back up\n            }\n        }\n        return root;\n    };\n    /**\n     * Convert a program AST to the programs-as-data format.\n     * The AST must be for a pure WHILE program.\n     * @returns {ProgDataType}\tThe program-as-data representation of the program\n     * @throws Error\tError if the program is not in pure WHILE format\n     */\n    ProgramManager.prototype.toPad = function () {\n        return progAsData_1.default(this.prog);\n    };\n    return ProgramManager;\n}());\nexports.default = ProgramManager;\n//# sourceMappingURL=ProgramManager.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TKN_DO_CONS = exports.TKN_CONS = exports.TKN_DO_TL = exports.TKN_TL = exports.TKN_DO_HD = exports.TKN_HD = exports.TKN_QUOTE = exports.TKN_VAR = exports.TKN_DO_IF = exports.TKN_IF = exports.TKN_DO_WHILE = exports.TKN_WHILE = exports.TKN_DO_ASSIGN = exports.TKN_ASSIGN_1 = exports.TKN_ASSIGN = exports.TKN_TRUE = exports.TKN_FALSE = exports.TKN_NIL = void 0;\nvar lexer_1 = __importDefault(require(\"../converter/lexer\"));\nexports.TKN_NIL = 'nil';\nexports.TKN_FALSE = 'false';\nexports.TKN_TRUE = 'true';\nexports.TKN_ASSIGN = '@asgn';\nexports.TKN_ASSIGN_1 = '@:=';\nexports.TKN_DO_ASSIGN = '@doAsgn';\nexports.TKN_WHILE = '@while';\nexports.TKN_DO_WHILE = '@doWhile';\nexports.TKN_IF = '@if';\nexports.TKN_DO_IF = '@doIf';\nexports.TKN_VAR = '@var';\nexports.TKN_QUOTE = '@quote';\nexports.TKN_HD = '@hd';\nexports.TKN_DO_HD = '@doHd';\nexports.TKN_TL = '@tl';\nexports.TKN_DO_TL = '@doTl';\nexports.TKN_CONS = '@cons';\nexports.TKN_DO_CONS = '@doCons';\nvar TOKEN_LIST = [\n    exports.TKN_FALSE, exports.TKN_TRUE,\n    exports.TKN_ASSIGN, exports.TKN_ASSIGN_1, exports.TKN_DO_ASSIGN,\n    exports.TKN_WHILE, exports.TKN_DO_WHILE,\n    exports.TKN_IF, exports.TKN_DO_IF,\n    exports.TKN_VAR, exports.TKN_QUOTE,\n    exports.TKN_HD, exports.TKN_DO_HD,\n    exports.TKN_TL, exports.TKN_DO_TL,\n    exports.TKN_CONS, exports.TKN_DO_CONS\n];\n/**\n * Lex a tree string into a token list.\n * Essentially a wrapper around ${@link lexer}\n * @param str\tThe string to lex\n */\nfunction lexTree(str) {\n    //Limit the accepted token strings to only those accepted by the parser\n    return lexer_1.default(str, TOKEN_LIST);\n}\nexports.default = lexTree;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TKN_PREN_CLS = exports.TKN_PREN_OPN = exports.TKN_LIST_CLS = exports.TKN_LIST_OPN = exports.TKN_TREE_CLS = exports.TKN_TREE_OPN = exports.TKN_CTR = exports.TKN_COMMA = exports.TKN_BAR = exports.TKN_DOTS = exports.TKN_DOT = void 0;\nvar LexerException_1 = __importDefault(require(\"../exceptions/LexerException\"));\n//Symbols\nexports.TKN_DOT = '.';\nexports.TKN_DOTS = '...';\nexports.TKN_BAR = '|';\nexports.TKN_COMMA = ',';\nexports.TKN_CTR = ':';\nexports.TKN_TREE_OPN = '<';\nexports.TKN_TREE_CLS = '>';\nexports.TKN_LIST_OPN = '[';\nexports.TKN_LIST_CLS = ']';\nexports.TKN_PREN_OPN = '(';\nexports.TKN_PREN_CLS = ')';\nvar SYMBOL_LIST = [\n    exports.TKN_DOTS, exports.TKN_DOT,\n    exports.TKN_CTR,\n    exports.TKN_COMMA, exports.TKN_BAR,\n    exports.TKN_TREE_OPN, exports.TKN_TREE_CLS,\n    exports.TKN_LIST_OPN, exports.TKN_LIST_CLS,\n    exports.TKN_PREN_OPN, exports.TKN_PREN_CLS,\n];\nfunction lexer(str, literals) {\n    if (literals === void 0) { literals = true; }\n    var res = [];\n    var pos = 0;\n    while (str.length) {\n        //Remove any whitespace characters from the start of the string\n        var startingLength = str.length;\n        str = str.trimStart();\n        pos += startingLength - str.length;\n        //Stop if the remaining characters were all whitespace\n        if (!str)\n            break;\n        //Check to see if the next token is a symbol\n        var token = _checkForSymbolToken(str);\n        if (token !== null) {\n            res.push(token);\n            pos += token.length;\n            str = str.substr(token.length);\n            continue;\n        }\n        //Check to see if the next token is a number\n        var num = _checkForNumberToken(str);\n        if (num !== null) {\n            res.push(num[0]);\n            pos += num[1];\n            str = str.substr(num[1]);\n            continue;\n        }\n        //Check to see if the next token is an atomic type\n        var atom = _checkForAtomToken(str);\n        if (atom != null) {\n            if (!_isTokenAllowed(atom, literals))\n                throw _unexpectedToken(atom, pos);\n            //Allow any token otherwise\n            res.push(atom);\n            pos += atom.length;\n            str = str.substr(atom.length);\n            continue;\n        }\n        //Unknown token\n        throw _unexpectedToken(str.charAt(0), pos);\n    }\n    return res;\n}\nexports.default = lexer;\n/**\n * Check whether an atomic literal type is allowed given the rules\n * @param atom\t\t\tThe atom string to check\n * @param literals\t\tWhich atomic type literals to allow.\n * \t\t\t\t\t\tnumbers (0,1,...) and {@code 'nil'} are always allowed.\n * \t\t\t\t\t\t{@code false} to allow no further literals.\n * \t\t\t\t\t\t{@code true} to allow any literal (matching the regex {@code /[a-z0-9_]+/i}).\n * \t\t\t\t\t\t{@code string[]} to whitelist only select further literals.\n */\nfunction _isTokenAllowed(atom, literals) {\n    //`nil` is always allowed\n    //Other atoms are accepted if `literals` is true\n    if (atom === 'nil' || literals === true)\n        return true;\n    //All other literals are rejected\n    if (literals === false)\n        return false;\n    //Otherwise check if the literal was whitelisted\n    return literals.includes(atom);\n}\n/**\n * Create an \"unexpected token\" error\n * @param token\tThe unexpected token\n * @param pos\tThe position the token was found at\n */\nfunction _unexpectedToken(token, pos) {\n    return new LexerException_1.default(\"SyntaxError: Unexpected token '\" + token + \"' at position \" + pos);\n}\n/**\n * Get the symbol token matching the start of the provided string.\n * @param str\tThe string to check\n * @example {@code '<nil>'} returns {@code '<'}\n * @example {@code 'nil>'} returns {@code null}\n * @example {@code '[]'} returns {@code '['}\n * @returns\tThe matching token string, or {@code null} if there isn't a match\n */\nfunction _checkForSymbolToken(str) {\n    for (var _i = 0, SYMBOL_LIST_1 = SYMBOL_LIST; _i < SYMBOL_LIST_1.length; _i++) {\n        var token = SYMBOL_LIST_1[_i];\n        if (str.substr(0, token.length) === token)\n            return token;\n    }\n    return null;\n}\n/**\n * Get a number matching the start of the provided string.\n * @param str\tThe string to check\n * @example\t{@code '0'}\treturns {@code [0, 1]}\n * @example\t{@code '1'}\treturns {@code [1, 1]}\n * @example\t{@code '99'} returns {@code [99, 2]}\n * @example\t{@code '10 20'} returns {@code [10, 2]}\n * @example\t{@code 'hi'} returns {@code null}\n * @returns\tThe found number and the length of its string, or {@code null} if there isn't a match\n */\nfunction _checkForNumberToken(str) {\n    var match = /^\\d+/.exec(str);\n    if (!match)\n        return null;\n    return [Number.parseInt(match[0]), match[0].length];\n}\n/**\n * Get an atom matching the start of the provided string.\n * This will be the longest string consisting of the alphanumeric characters (a-z, 0-9) in any case, and '_'.\n * @param str\tThe string to check\n * @example {@code '<nil>'} returns {@code null}\n * @example {@code 'nil>'} returns {@code nil}\n * @example {@code 'nilish'} returns {@code 'nilish'}\n * @example {@code 'my atom'} returns {@code 'my'}\n * @returns\tThe matching atom string, or {@code null} if there isn't a match\n */\nfunction _checkForAtomToken(str) {\n    var match = /^[@a-z_'][a-z0-9_':=]*/i.exec(str);\n    if (!match)\n        return null;\n    return match[0];\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar lexer_1 = require(\"./lexer\");\nvar parser_1 = require(\"../utils/parser\");\nvar ParserException_1 = __importDefault(require(\"../exceptions/ParserException\"));\n//========\n// Utils\n//========\n/**\n * Get whether the last read token should be treated as a list.\n * (it is followed by `{@code TKN_LIST_OPEN}, {@code TKN_LIST_CLS}`).\n * The next 2 tokens are removed from the list if `true`.\n * Nothing is changed otherwise\n * @param tokens\n * @returns `false` if the next token is not {@code TKN_LIST_OPEN}\n * @returns `true` if the next two tokens are {@code TKN_LIST_OPEN} and {@code TKN_LIST_CLS}\n * @throws ParserException if the next token is {@code TKN_LIST_OPEN} and is not followed by {@code TKN_LIST_CLS}\n */\nfunction _isList(tokens) {\n    //The next element must be followed by a `TKN_LIST_OPN`\n    if (tokens[0] !== lexer_1.TKN_LIST_OPN)\n        return false;\n    //Remove the opening bracket\n    tokens.shift();\n    //The next token must be a closing bracket\n    parser_1._expect(tokens, lexer_1.TKN_LIST_CLS);\n    //A valid tree was received\n    return true;\n}\n/**\n * Add a child node to a parent `choice` type.\n * This unwraps unnecessarily nested `choice` nodes.\n * @param parent\tThe parent node\n * @param child\t\tThe child node to add\n */\nfunction _addToChoice(parent, child) {\n    var _a;\n    //Add strings and numbers directly\n    if (typeof child === 'string' || typeof child === 'number')\n        parent.type.push(child);\n    //Unwrap nested choice nodes\n    else if (child.category === 'choice')\n        (_a = parent.type).push.apply(_a, child.type);\n    //Add other types as-is\n    else\n        parent.type.push(child);\n    return parent;\n}\n/**\n * Parse the internals of a list.\n * Expects the {@code TKN_LST_OPN} to have already been consumed\n * @param tokens\tThe token list\n */\nfunction _interpretListInternal(tokens) {\n    //Check if the next element says to ignore the rest of the list\n    if (tokens[0] === lexer_1.TKN_DOTS) {\n        //Remove the dots\n        tokens.shift();\n        //This should be the last element before the end fof the list\n        parser_1._expect(tokens, lexer_1.TKN_LIST_CLS);\n        //Allow any node here - only limit is that the rightmost leaf node is `nil`\n        //Which is a guaranteed quality of the binary tree\n        return {\n            category: 'choice',\n            type: ['any'],\n        };\n    }\n    //Parse the first element of the list\n    var left = _readAllAtoms(tokens);\n    //The next token should either be a comma, or list closing token\n    var token = parser_1._expect(tokens, lexer_1.TKN_COMMA, lexer_1.TKN_LIST_CLS);\n    var right;\n    if (token === lexer_1.TKN_LIST_CLS) {\n        //If the list ends here, the right node should be `nil`\n        right = {\n            category: 'choice',\n            type: ['nil']\n        };\n    }\n    else {\n        //Otherwise, continue parsing the list\n        right = _interpretListInternal(tokens);\n    }\n    //Return the created list node\n    return {\n        category: 'tree',\n        left: left,\n        right: right,\n    };\n}\n//========\n// Atoms\n//========\n/**\n * Read the next atom (nil/int/nil[]/int[]/nil[][]...) from the token list\n * @param tokens\tThe token list\n */\nfunction _readAtom(tokens) {\n    //Read the first token in the list, or error if it doesn't exist\n    var first = parser_1._expect(tokens);\n    var res;\n    switch (first) {\n        //These should only ever be encountered by type-specific methods\n        //Never by this method directly\n        case lexer_1.TKN_BAR:\n        case lexer_1.TKN_COMMA:\n        case lexer_1.TKN_CTR:\n        case lexer_1.TKN_DOT:\n        case lexer_1.TKN_DOTS:\n        case lexer_1.TKN_LIST_CLS:\n        case lexer_1.TKN_PREN_CLS:\n        case lexer_1.TKN_TREE_CLS:\n            throw parser_1._unexpectedToken(first);\n        //Interpret the next part of the token list as a tree\n        case lexer_1.TKN_TREE_OPN:\n            res = _interpretTree(tokens);\n            break;\n        //Read the contents of the parentheses\n        case lexer_1.TKN_PREN_OPN:\n            res = _interpretParen(tokens);\n            break;\n        case lexer_1.TKN_LIST_OPN:\n            res = _interpretList(tokens);\n            break;\n        //Allow atomic types\n        default:\n            res = {\n                category: 'choice',\n                type: [first],\n            };\n    }\n    //Wrap in nested lists as needed\n    while (_isList(tokens)) {\n        res = {\n            category: 'list',\n            type: res\n        };\n    }\n    //Unwrap `choice`s of single items\n    //This just saves unnecessarily wrapping all leaf nodes in a `choice`\n    if (res.category === 'choice' && res.type.length === 1)\n        return res.type[0];\n    //Return the produced type\n    return res;\n}\n/**\n * Read as many atoms as possible (atom[|atom[|atom[...]]]) from the token list\n * @param tokens\n */\nfunction _readAllAtoms(tokens) {\n    //The parent of all the read atoms\n    var res = {\n        category: 'choice',\n        type: [],\n    };\n    //Read the next atom\n    _addToChoice(res, _readAtom(tokens));\n    while (tokens[0] === lexer_1.TKN_BAR) {\n        //Remove the separator from the head of the list\n        tokens.shift();\n        //Read the next atom\n        _addToChoice(res, _readAtom(tokens));\n    }\n    //Unwrap `choice`s of single items\n    if (res.category === 'choice' && res.type.length === 1) {\n        var t = res.type[0];\n        if (typeof t !== 'string' && typeof t !== 'number')\n            return t;\n    }\n    //Return the produced type\n    return res;\n}\n//========\n//Sections\n//========\n/**\n * Read a pair of parentheses and their content from the token list.\n * Expects the opening paren to have already been removed from the list.\n * @param tokens\tThe token list\n */\nfunction _interpretParen(tokens) {\n    //Read the contents of the parentheses\n    var tree = _readAllAtoms(tokens);\n    //Expect a closing paren\n    parser_1._expect(tokens, lexer_1.TKN_PREN_CLS);\n    //Return the produced type\n    return tree;\n}\n/**\n * Read a tree and its children from the token list.\n * Expects the opening symbol to have already been removed from the list.\n * @param tokens\tThe token list\n */\nfunction _interpretTree(tokens) {\n    //Read the left-hand child\n    var left = _readAllAtoms(tokens);\n    //Expect a separator between the elements\n    parser_1._expect(tokens, lexer_1.TKN_DOT);\n    //Read the right-hand child\n    var right = _readAllAtoms(tokens);\n    //Expect a matching closing bracket\n    parser_1._expect(tokens, lexer_1.TKN_TREE_CLS);\n    //Return the tree type\n    return {\n        category: \"tree\",\n        left: left,\n        right: right,\n    };\n}\n/**\n * Read a fixed type list from the token list.\n * Expects the opening symbol to have already been removed from the token list.\n * @param tokens\tThe token list\n */\nfunction _interpretList(tokens) {\n    //Return a `nil` token if the list has no content\n    if (tokens[0] === lexer_1.TKN_LIST_CLS) {\n        tokens.shift();\n        return {\n            category: 'choice',\n            type: ['nil']\n        };\n    }\n    //Parse the elements of the list\n    return _interpretListInternal(tokens);\n}\n/**\n * Parse a token list into a conversion tree.\n * This is an intermediate step between lexing the string and converting the tree\n * @param tokens\tThe token list to parse\n */\nfunction parse(tokens) {\n    //Treat an empty input list as matching any tree\n    if (tokens.length === 0)\n        tokens = ['any'];\n    //Parse the token list\n    var res = _readAllAtoms(tokens);\n    //Error if there are any unparsed tokens left\n    if (tokens.length > 0)\n        throw new ParserException_1.default(\"Unexpected token: '\" + tokens[0] + \"'\");\n    //Unwrap the root node if it is a choice of only 1 option\n    if (res.category === 'choice' && res.type.length === 1) {\n        var t = res.type[0];\n        if (typeof t !== 'string' && typeof t !== 'number')\n            return t;\n    }\n    //Return the produced tree\n    return res;\n}\nexports.default = parse;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.displayPad = exports.HWHILE_DISPLAY_FORMAT = exports.PURE_DISPLAY_FORMAT = exports.fromPad = void 0;\nvar tslib_1 = require(\"tslib\");\nvar VariableManager_1 = tslib_1.__importStar(require(\"../utils/VariableManager\"));\nvar StringBuilder_1 = require(\"../utils/StringBuilder\");\n/**\n * Convert a program AST to the programs-as-data format.\n * The AST must be for a pure WHILE program.\n * @returns {ProgDataType}\tThe program-as-data representation of the program\n * @throws Error\tError if the program is not in pure WHILE format\n */\nfunction toPad(prog) {\n    var e_1, _a;\n    //Create a variable manager for the conversion\n    var manager = new VariableManager_1.VariableManager();\n    manager.add(prog.input.value);\n    //Convert each command of the program body to the data representation\n    var programBody = [];\n    try {\n        for (var _b = tslib_1.__values(prog.body), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var el = _c.value;\n            programBody.push(_convertToData(el, manager));\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    //Return the program's data representation\n    return [\n        manager.index(prog.input.value),\n        programBody,\n        manager.add(prog.output.value),\n    ];\n}\nexports.default = toPad;\n/**\n * Convert a program command to its data representation\n * @param line\t\tThe command to convert\n * @param manager\tVariable manager to assist with converting the command\n * @private\n */\nfunction _convertToData(line, manager) {\n    switch (line.type) {\n        case \"assign\":\n            return [\n                ':=',\n                manager.add(line.ident.value),\n                _convertToDataExpr(line.arg, manager)\n            ];\n        case \"cond\":\n            return [\n                'if',\n                _convertToDataExpr(line.condition, manager),\n                line.if.map(function (l) { return _convertToData(l, manager); }),\n                line.else.map(function (l) { return _convertToData(l, manager); }),\n            ];\n        case \"loop\":\n            return [\n                'while',\n                _convertToDataExpr(line.condition, manager),\n                line.body.map(function (l) { return _convertToData(l, manager); }),\n            ];\n        default:\n            throw new Error(\"Unsupported feature '\" + line.type + \"'. Ensure the program is in pure WHILE.\");\n    }\n}\n/**\n * Convert an expression to its data representation\n * @param line\t\tThe expression to convert\n * @param manager\tVariable manager to assist with converting the expression\n * @private\n */\nfunction _convertToDataExpr(line, manager) {\n    switch (line.type) {\n        case \"identName\":\n            return ['var', manager.add(line.value)];\n        case \"operation\":\n            switch (line.op.value) {\n                case \"cons\":\n                    return [\n                        'cons',\n                        _convertToDataExpr(line.args[0], manager),\n                        _convertToDataExpr(line.args[1], manager),\n                    ];\n                case \"hd\":\n                case \"tl\":\n                    return [\n                        line.op.value,\n                        _convertToDataExpr(line.args[0], manager),\n                    ];\n                case \"true\":\n                case \"false\":\n                default:\n                    throw new Error(\"Unsupported feature '\" + line.type + \"'. Ensure the program is in pure WHILE.\");\n            }\n        case \"tree\":\n            if (line.tree === null)\n                return ['quote', 'nil'];\n            throw new Error(\"Unsupported feature '\" + line.type + \"'. Ensure the program is in pure WHILE.\");\n        case \"equal\":\n        case \"list\":\n        case \"macro\":\n        case \"tree_expr\":\n            throw new Error(\"Unsupported feature '\" + line.type + \"'. Ensure the program is in pure WHILE.\");\n    }\n}\n/**\n * Convert a programs-as-data object to a program AST\n * @param data\tThe PaD object to convert\n * @param name\tTe AST represented by the input object\n */\nfunction fromPad(data, name) {\n    var e_2, _a;\n    if (name === void 0) { name = 'prog'; }\n    //Create a variable manager to control the data\n    var variableManager = new VariableManager_1.default();\n    //Assign the input variable a name\n    variableManager.addAnonymous(data[0]);\n    //Convert each command in the program body to an AST\n    var body = [];\n    try {\n        for (var _b = tslib_1.__values(data[1]), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var c = _c.value;\n            body.push(_cmdFromPad(c, variableManager));\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    //Create an AST_PROG object\n    return {\n        type: 'program',\n        complete: true,\n        //Program name\n        name: { type: 'identName', value: name },\n        //Input variable name\n        input: { type: 'identName', value: variableManager.addAnonymous(data[0]) },\n        //Output variable name\n        output: { type: 'identName', value: variableManager.addAnonymous(data[2]) },\n        //Program body\n        body: body,\n    };\n}\nexports.fromPad = fromPad;\n/**\n * Convert a program-as-data command to an AST subtree\n * @param data\t\tThe pad command object\n * @param manager\tVariable manager for reading/assigning variable names\n */\nfunction _cmdFromPad(data, manager) {\n    /*\n    Create a stack to hold the commands/subcommands while converting from PAD\n    At each point the stack contains the following:\n     [0] The data-list to convert to a command\n     [1] A list of AST commands, containing the so-far converted commands of this operation's body\n            For assignment operations, this is empty.\n            For loops, there are is one sublist (the loop body).\n            For conditionals, there are two lists (if-body, else-body).\n     [2] The parent command's body list, into which this command should be placed\n    */\n    var root = [];\n    var cmdStack = [\n        [data, [], root]\n    ];\n    while (cmdStack.length > 0) {\n        //Read the top element of the stack\n        var _a = tslib_1.__read(cmdStack.pop(), 3), data_1 = _a[0], cmds = _a[1], parentCmds = _a[2];\n        switch (data_1[0]) {\n            case \":=\":\n                //Directly place the assignment command into the parent's body\n                parentCmds.push({\n                    type: 'assign',\n                    complete: true,\n                    ident: { type: 'identName', value: manager.addAnonymous(data_1[1]) },\n                    arg: _exprFromPad(data_1[2], manager),\n                });\n                break;\n            case \"while\":\n                //Create a new body sublist to hold the body commands\n                if (cmds.length === 0)\n                    cmds.push([]);\n                if (cmds.length === 1 && cmds[0].length === data_1[2].length) {\n                    //The command has been fully converted\n                    //Add it to the end of parent's body\n                    parentCmds.push({\n                        type: 'loop',\n                        complete: true,\n                        condition: _exprFromPad(data_1[1], manager),\n                        body: cmds[0],\n                    });\n                }\n                else {\n                    //Push this command back onto the stack\n                    cmdStack.push([data_1, cmds, parentCmds]);\n                    //Push the next unconverted command from the body to the stack\n                    cmdStack.push([data_1[2][cmds[0].length], [], cmds[0]]);\n                }\n                break;\n            case \"if\":\n                //Add a new body list if one has not been created\n                //Or if the first one has been filled\n                if (cmds.length === 0)\n                    cmds.push([]);\n                if (cmds.length === 1 && cmds[0].length === data_1[2].length)\n                    cmds.push([]);\n                if (cmds.length === 2 && cmds[0].length === data_1[2].length && cmds[1].length === data_1[3].length) {\n                    //The if and else bodies have both been fully converted\n                    //Add this command to the end of parent's body\n                    parentCmds.push({\n                        type: 'cond',\n                        complete: true,\n                        condition: _exprFromPad(data_1[1], manager),\n                        if: cmds[0],\n                        else: cmds[1],\n                    });\n                }\n                else {\n                    //Push this command back onto the stack\n                    cmdStack.push([data_1, cmds, parentCmds]);\n                    if (cmds.length === 1) {\n                        //Push the next unconverted if-body command onto the stack\n                        cmdStack.push([data_1[2][cmds[0].length], [], cmds[0]]);\n                    }\n                    else if (cmds.length === 2) {\n                        //Push the next unconverted else-body command onto the stack\n                        cmdStack.push([data_1[3][cmds[1].length], [], cmds[1]]);\n                    }\n                }\n                break;\n        }\n    }\n    //Return the produced command\n    //This will be the only element of the `root` array\n    return root[0];\n}\n/**\n * Convert a program-as-data expression to an AST subtree\n * @param data\t\tThe pad expression object\n * @param manager\tVariable manager for reading/assigning variable names\n */\nfunction _exprFromPad(data, manager) {\n    /*\n    Create a stack to hold the (sub)expressions while converting from PAD\n    At each point the stack contains the following:\n     * The data-list to convert to an expression\n     * A list of AST expressions, containing the so-far converted elements of this operation\n     * The parent expression's expression list\n    */\n    var root = [];\n    var exprStack = [\n        [data, [], root]\n    ];\n    while (exprStack.length > 0) {\n        //Read the top element of the stack\n        var _a = tslib_1.__read(exprStack.pop(), 3), data_2 = _a[0], expr = _a[1], parent_1 = _a[2];\n        if (data_2[0] === \"quote\") {\n            //Convert a 'nil' quoted value to a nil value\n            if (data_2[1] !== 'nil')\n                throw new Error(\"Unsupported quote \\\"\" + data_2[1] + \"\\\", expected \\\"nil\\\"\");\n            parent_1.push({\n                type: 'tree',\n                complete: true,\n                tree: null,\n            });\n        }\n        else if (data_2[0] === \"var\") {\n            //Read the variable value\n            parent_1.push({\n                type: 'identName',\n                //Get the variable's name from the number, or assign a name if it is not yet defined\n                value: manager.addAnonymous(data_2[1]),\n            });\n            //From here, the data can only be an operation (cons/hd/tl)\n        }\n        else if (expr.length === 0) {\n            //All operations need at least one expression as argument\n            //Add the first argument in the list to the stack\n            exprStack.push([data_2, expr, parent_1]);\n            exprStack.push([data_2[1], [], expr]);\n        }\n        else if (data_2[0] === 'cons' && expr.length === 1) {\n            //If the first argument of a 'cons' has been converted\n            //Add the second one to the stack\n            exprStack.push([data_2, expr, parent_1]);\n            exprStack.push([data_2[2], [], expr]);\n        }\n        else {\n            //If all the arguments are converted\n            //Add them all to the parent operation's arg list\n            parent_1.push({\n                type: 'operation',\n                complete: true,\n                op: { type: 'opToken', value: data_2[0] },\n                args: expr,\n            });\n        }\n    }\n    //Return the produced expression\n    //This will be the only element of the `root` array\n    return root[0];\n}\n/**\n * Predefined options for displaying PaD objects in a \"pure\" format\n */\nexports.PURE_DISPLAY_FORMAT = {\n    assign: ':=',\n    if: 'if',\n    while: 'while',\n    quote: 'quote',\n    var: 'var',\n    cons: 'cons',\n    hd: 'hd',\n    tl: 'tl',\n};\n/**\n * Predefined options for displaying PaD objects in the same format as HWhile\n */\nexports.HWHILE_DISPLAY_FORMAT = {\n    assign: '@:=',\n    if: '@if',\n    while: '@while',\n    quote: '@quote',\n    var: '@var',\n    cons: '@cons',\n    hd: '@hd',\n    tl: '@tl',\n};\n/**\n * Produce a program string from the stored program AST\n * @param data\t\tThe program-as-data object to display\n * @param format\tFormatting options to use to display the text\n * @param indent\tThe character(s) to use to indicate a single indent.\n * \t\t\t\t\tDefaults to 4 spaces.\n */\nfunction displayPad(data, format, indent) {\n    if (indent === void 0) { indent = '    '; }\n    //Make a builder to build up the output string\n    var builder = new StringBuilder_1.StringBuilder({ indent: indent });\n    //Make a command stack to allow for iterative traversal through the pad tree\n    var commandStack = [];\n    //Display the opening \"[0, \"\n    builder.add(\"[\").add(data[0]).add(', ');\n    //Display the body opening paren, and add the body to the stack for evaluation\n    _displayBody(data[1], commandStack, builder);\n    //Evaluate the stack until complete\n    _evalDisplayStack(commandStack, builder, format);\n    //Display the body closing paren\n    _displayBodyClose(data[1], builder);\n    //Display the closing \", 1]\"\n    builder.add(\", \").add(data[2]).add(\"]\");\n    //Add a trailing new line\n    builder.break();\n    //Return the produced element as a string\n    return builder.toString();\n}\nexports.displayPad = displayPad;\n/**\n * Display the opening square bracket for a body block, indent the output, and add all the body's commands to the stack.\n * A trailing comma is added after each command, except the final one\n * @param data\t\t\tThe body to evaluate\n * @param commandStack\tCommand stack to use\n * @param builder\t\tString builder to use\n */\nfunction _displayBody(data, commandStack, builder) {\n    //Open the body's bracket\n    builder.add('[');\n    if (data.length > 0) {\n        //Only add a line break if the body is non-empty\n        builder.break().indent();\n        //Add the final element to the top of the stack\n        commandStack.push({ data: data[data.length - 1], level: 0 });\n        //Add the rest of the elements to the stack (in reverse order) with trailing commas\n        for (var i = data.length - 2; i >= 0; i--) {\n            commandStack.push({\n                data: data[i],\n                level: 0,\n                terminator: ','\n            });\n        }\n    }\n}\n/**\n * Display the closing bracket (and optionally dedent) to a code body.\n * @param data\t\tThe data object being closed\n * @param builder\tString builder to use\n */\nfunction _displayBodyClose(data, builder) {\n    if (data.length > 0)\n        builder.dedent();\n    builder.add(\"]\");\n}\n/**\n * Evaluate the {@code commandStack} object to render a programs-as-data object as a string\n * @param commandStack\tThe command stack to evaluate\n * @param builder\t\tThe\n * @param format\t\tprog-as-data formatting options\n */\nfunction _evalDisplayStack(commandStack, builder, format) {\n    //Loop until the stack is empty\n    while (commandStack.length > 0) {\n        //Pop the element off the top of the stack\n        var currLevel = commandStack.pop();\n        var data = currLevel.data;\n        //Open the list's bracket if this is the first time the element is reached\n        if (currLevel.level === 0)\n            builder.add('[');\n        //If the list has been completely displayed, end here\n        if (currLevel.level >= data.length) {\n            //Close the list's bracket\n            builder.add(']');\n            //Display the terminating symbols, if requested\n            if (currLevel.terminator)\n                builder.add(currLevel.terminator);\n            //Add a terminating linebreak if the object is a command\n            if (data[0] === ':=' || data[0] === 'if' || data[0] === 'while')\n                builder.break();\n            //Travel down the stack\n            continue;\n        }\n        //The format of the rest of the elements is dependent on the type of element\n        switch (data[0]) {\n            case \":=\":\n                //Display \":=, 0, \"\n                builder.add(format.assign).add(', ').add(data[1]).add(', ');\n                //Complete next time this is the top of the stack\n                currLevel.level = 3;\n                commandStack.push(currLevel);\n                //Display the argument next\n                commandStack.push({ data: data[2], level: 0 });\n                break;\n            case \"while\":\n            case \"if\":\n                if (currLevel.level === 0) {\n                    //Display \"while, \" or \"if, \"\n                    builder\n                        .add(data[0] === 'while' ? format.while : format.if)\n                        .add(', ');\n                    //Display the first body next time this is the top of the stack\n                    currLevel.level = 1;\n                    commandStack.push(currLevel);\n                    //Display the condition next\n                    commandStack.push({ data: data[1], level: 0 });\n                }\n                else if (currLevel.level === 1) {\n                    //Display a comma between the expression and body start\n                    builder.add(', ');\n                    //Perform the next step next time this is the top of the stack\n                    currLevel.level = 2;\n                    commandStack.push(currLevel);\n                    //Display the loop body (or if-true body) next\n                    _displayBody(data[2], commandStack, builder);\n                }\n                else if (data[0] === 'if' && currLevel.level === 2) {\n                    //Close the body list and add a training command\n                    _displayBodyClose(data[2], builder);\n                    builder.add(', ');\n                    //Close the body the next time this is the top of the stack\n                    currLevel.level = 3;\n                    commandStack.push(currLevel);\n                    //Display the else block\n                    _displayBody(data[3], commandStack, builder);\n                }\n                else {\n                    //Close the body list\n                    _displayBodyClose(data[2], builder);\n                    //Complete on the next iteration\n                    currLevel.level = 4;\n                    commandStack.push(currLevel);\n                }\n                break;\n            case \"var\":\n            case \"quote\":\n                //Display \"var, 0\" or \"quote, nil\"\n                builder\n                    .add(data[0] === 'var' ? format.var : format.quote)\n                    .add(', ').add(data[1]);\n                //Complete on the next iteration\n                currLevel.level = 2;\n                commandStack.push(currLevel);\n                break;\n            case \"cons\":\n                if (currLevel.level === 0) {\n                    //Display \"cons, \"\n                    builder.add(format.cons).add(', ');\n                    //Display the second argument the next time this is the top of the stack\n                    currLevel.level = 2;\n                    commandStack.push(currLevel);\n                    //Display the first argument on the next iteration\n                    commandStack.push({ data: data[1], level: 0 });\n                }\n                else {\n                    //Add a comma between the arguments\n                    builder.add(', ');\n                    //Complete next time this is the top of the stack\n                    currLevel.level = 3;\n                    commandStack.push(currLevel);\n                    //Display the second argument next iteration\n                    commandStack.push({ data: data[2], level: 0 });\n                }\n                break;\n            case \"hd\":\n            case \"tl\":\n                //Display \"hd, \" or \"tl, \"\n                builder\n                    .add(data[0] === 'hd' ? format.hd : format.tl)\n                    .add(', ');\n                //Complete next time this is at the top of the stack\n                currLevel.level = 2;\n                commandStack.push(currLevel);\n                //Display the argument on the next iteration\n                commandStack.push({ data: data[1], level: 0 });\n                break;\n            default:\n                throw new Error(\"Unknown data type \\\"\" + data[0] + \"\\\"\");\n        }\n    }\n}\n//# sourceMappingURL=progAsData.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseProgram = void 0;\nvar tslib_1 = require(\"tslib\");\nvar lexer_1 = tslib_1.__importDefault(require(\"./lexer\"));\nvar parser_1 = tslib_1.__importDefault(require(\"./parser\"));\n/**\n * Parse a program string and return any errors discovered in the code\n * @param program\t\tThe program to parse\n * @param props\t\t\tConfiguration options for the linter\n */\nfunction lint(program, props) {\n    //Configure lexer and parser options\n    var lexerOpts = (props === null || props === void 0 ? void 0 : props.lexOpts) || {};\n    var parseOpts = (props === null || props === void 0 ? void 0 : props.parseOpts) || {};\n    if ((props === null || props === void 0 ? void 0 : props.pureOnly) === true) {\n        lexerOpts.pureOnly = true;\n        parseOpts.pureOnly = true;\n    }\n    //Pass the program through the lexer and parer\n    var _a = tslib_1.__read(lexer_1.default(program, lexerOpts), 2), tokens = _a[0], lexErrors = _a[1];\n    var _b = tslib_1.__read(parser_1.default(tokens, parseOpts), 2), parseErrors = _b[1];\n    //Combine the lexer and parser errors into a single list\n    return tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(lexErrors)), tslib_1.__read(parseErrors));\n}\nexports.default = lint;\n/**\n * Lex and parse a program string into an AST\n * @param program\tThe program to parse\n * @param props\t\tLexing/parsing options\n */\nfunction parseProgram(program, props) {\n    //Configure lexer and parser options\n    var lexerOpts = (props === null || props === void 0 ? void 0 : props.lexOpts) || {};\n    var parseOpts = (props === null || props === void 0 ? void 0 : props.parseOpts) || {};\n    if ((props === null || props === void 0 ? void 0 : props.pureOnly) === true) {\n        lexerOpts.pureOnly = true;\n        parseOpts.pureOnly = true;\n    }\n    //Pass the program through the lexer and parer\n    var _a = tslib_1.__read(lexer_1.default(program, lexerOpts), 2), tokens = _a[0], lexErrors = _a[1];\n    var _b = tslib_1.__read(parser_1.default(tokens, parseOpts), 2), ast = _b[0], parseErrors = _b[1];\n    //Combine the lexer and parser errors into a single list\n    return [ast, tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(lexErrors)), tslib_1.__read(parseErrors))];\n}\nexports.parseProgram = parseProgram;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._expect = exports._unexpectedToken = void 0;\nvar ParserException_1 = __importDefault(require(\"../exceptions/ParserException\"));\n/**\n * Create an error object for when an expected token is received\n * @param actual\tThe actual token received\n * @param expected\tThe expected token (or undefined)\n */\nfunction _unexpectedToken(actual) {\n    var expected = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        expected[_i - 1] = arguments[_i];\n    }\n    if (expected.length === 0)\n        return new ParserException_1.default(\"Unexpected token: '\" + actual + \"'\");\n    if (expected.length === 1)\n        return new ParserException_1.default(\"Unexpected token: expected '\" + expected[0] + \"' got '\" + actual + \"'\");\n    return new ParserException_1.default(\"Unexpected token: expected one of '\" + expected.join(\"', '\") + \"' got '\" + actual + \"'\");\n}\nexports._unexpectedToken = _unexpectedToken;\n/**\n * Read the next token from the list.\n * Throws an error if the token list is empty, or if the token doesn't match the expected value\n * @param tokens\tThe token list\n * @param expected\tThe expected token. May be undefined to accept any token.\n */\nfunction _expect(tokens) {\n    var expected = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        expected[_i - 1] = arguments[_i];\n    }\n    //Read the next token in the list\n    var first = tokens.shift();\n    //Unexpected end of token list\n    if (first === undefined) {\n        if (expected.length === 0)\n            throw new ParserException_1.default(\"Unexpected end of input\");\n        else if (expected.length === 1)\n            throw new ParserException_1.default(\"Unexpected end of input: Expected '\" + expected[0] + \"'\");\n        else\n            throw new ParserException_1.default(\"Unexpected end of input: Expected one of '\" + expected.join(\"', '\") + \"'\");\n    }\n    //Allow any token if no expected was provided\n    if (expected.length === 0)\n        return first;\n    //The token matches the expected value\n    if (expected.includes(first))\n        return first;\n    //The token is unexpected - throw an error\n    throw _unexpectedToken.apply(void 0, __spreadArray([first], expected));\n}\nexports._expect = _expect;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParserException = /** @class */ (function (_super) {\n    __extends(ParserException, _super);\n    function ParserException(message) {\n        return _super.call(this, message) || this;\n    }\n    return ParserException;\n}(Error));\nexports.default = ParserException;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Combine a list of trees into a single string, separated by a separator.\n * This is for building the inside of trees/lists\n * @param children  The trees to combine\n * @param sep       The character(s) used to separate the trees\n */\nfunction buildChildren(children, sep) {\n    if (sep === void 0) { sep = '.'; }\n    var res = '';\n    for (var i = 0; i < children.length; i++) {\n        res += stringify(children[i]);\n        if (i < children.length - 1)\n            res += sep;\n    }\n    return res;\n}\n/**\n * Convert a value to its string format.\n * @param value     The value to convert\n */\nfunction stringifyVal(value) {\n    //Undefined/null values are 'nil'\n    if (value === undefined || value === null)\n        return \"nil\";\n    //Stringify numbers\n    else if (typeof value === \"number\")\n        return \"\" + value;\n    //Keep booleans as-is\n    else if (value === \"true\" || value === \"false\")\n        return value;\n    //Wrap strings in \"\"\n    else\n        return \"\\\"\" + value + \"\\\"\";\n}\n/**\n * Produce a string representation of a {@code ConvertedBinaryTree} object\n * @param tree  The tree to stringify\n * @return  String representing the tree\n */\nfunction stringify(tree) {\n    var children = tree.children || [];\n    //Stringify lists\n    if (tree.list)\n        return \"[\" + buildChildren(children, ',') + \"]\";\n    //Stringify tree types\n    if (children.length)\n        return \"<\" + buildChildren(children, '.') + \">\";\n    //Otherwise stringify the node's value\n    return stringifyVal(tree.value);\n}\nexports.default = stringify;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/**\n * Generator class to sequentially create unique strings.\n * Strings start at 'A', then 'B', 'C' etc until 'Z', then 'AA', 'AB', ... 'ZZ', 'AAA', 'AAB', ...\n */\nvar NameGenerator = /** @class */ (function () {\n    /**\n     * @param minLength\t\tThe length of the first string to produce.\n     * \t\t\t\t\t\tThe first string is the character 'A' repeated {@code minLength} times.\n     */\n    function NameGenerator(minLength) {\n        if (minLength === void 0) { minLength = 1; }\n        if (minLength <= 0)\n            minLength = 1;\n        this._nextName = [];\n        for (var i = 0; i < minLength; i++)\n            this._nextName.push('A');\n    }\n    /**\n     * Get the next string in the generator.\n     * @param increment\t\tWhether to mark the name as completed and move onto the next name.\n     * \t\t\t\t\t\tUsing {@code false} will return the same value on the next iteration.\n     * \t\t\t\t\t\t{@code true} will produce a new value on the next iteration.\n     */\n    NameGenerator.prototype.next = function (increment) {\n        if (increment === void 0) { increment = true; }\n        //Join the name from a list into the name string\n        var res = this._nextName.join('');\n        //Increment the stored value if requested\n        if (increment)\n            this._incrementName();\n        //Return the string\n        return res;\n    };\n    NameGenerator.prototype._incrementName = function () {\n        var _a;\n        /**\n         * Get the following character, overflowing if required\n         * @param c\t\tThe current character value.\n         * @returns {[string, boolean]} The next value in the character's value, and whether or not the character has\n         * \t\t\t\t\t\t\t\tlooped round.\n         */\n        function _nextChar(c) {\n            //Character code of the following character\n            var code = c.charCodeAt(0) + 1;\n            //Overflow back to 'A' if the character has passed 'Z'\n            if (code > 'Z'.charCodeAt(0))\n                return ['A', true];\n            //Otherwise return the new character\n            return [String.fromCharCode(code), false];\n        }\n        //Increment the string by 1, overflowing where required\n        var c;\n        var looped;\n        var i = this._nextName.length - 1;\n        do {\n            _a = tslib_1.__read(_nextChar(this._nextName[i]), 2), c = _a[0], looped = _a[1];\n            this._nextName[i] = c;\n            if (i === 0 && looped) {\n                this._nextName.splice(0, 0, 'A');\n                break;\n            }\n            else {\n                i--;\n            }\n        } while (looped);\n    };\n    return NameGenerator;\n}());\nexports.default = NameGenerator;\n//# sourceMappingURL=NameGenerator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar StringBuilder_1 = require(\"../utils/StringBuilder\");\n/**\n * Produce a program string from the stored program AST\n * @param prog\t\tThe program AST to display\n * @param indent\tThe character(s) to use to indicate a single indent.\n * \t\t\t\t\tDefaults to {@code '\\t'} (a tab character).\n */\nfunction displayProgram(prog, indent) {\n    if (indent === void 0) { indent = '\\t'; }\n    var stringBuilder = new StringBuilder_1.StringBuilder({ indent: indent });\n    stringBuilder\n        .add(prog.name.value + \" read \" + prog.input.value + \" {\")\n        .break();\n    if (prog.body.length === 0)\n        stringBuilder.break();\n    else\n        _displayBody(prog.body, stringBuilder);\n    stringBuilder.add(\"} write \" + prog.output.value);\n    return stringBuilder.toString();\n}\nexports.default = displayProgram;\n/**\n * Convert a list of AST commands to a program string\n * @param body\t\t\tThe list of commands to convert\n * @param builder\tString Builder used to build the program\n */\nfunction _displayBody(body, builder) {\n    var e_1, _a;\n    builder.indent();\n    try {\n        for (var _b = tslib_1.__values(body.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var _d = tslib_1.__read(_c.value, 2), i = _d[0], cmd = _d[1];\n            //Convert each command to a string\n            _displayCmd(cmd, builder);\n            //Add a line separator to the end of every line except the last one\n            if (i < body.length - 1)\n                builder.add(';');\n            builder.break();\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    builder.dedent();\n}\n/**\n * Convert a single AST command to a program string\n * @param cmd\t\tThe command to convert\n * @param builder\tString Builder used to build the program\n */\nfunction _displayCmd(cmd, builder) {\n    var e_2, _a;\n    switch (cmd.type) {\n        case \"assign\":\n            //Add a space after the assignment operator only if the expression doesn't already add one\n            var expr = _displayExpr(cmd.arg);\n            builder.add(cmd.ident.value);\n            if (expr.charAt(0) === ' ')\n                builder.add(' :=').add(expr);\n            else\n                builder.add(' := ').add(expr);\n            return;\n        case \"cond\":\n            //The if statement and body\n            builder.add(\"if \").add(_displayExpr(cmd.condition)).add(' {').break();\n            _displayBody(cmd.if, builder);\n            //Display the else statement only if non-empty\n            if (cmd.else.length > 0) {\n                builder.add(\"} else {\").break();\n                _displayBody(cmd.else, builder);\n            }\n            builder.add('}');\n            return;\n        case \"loop\":\n            builder.add(\"while \").add(_displayExpr(cmd.condition)).add(\" {\").break();\n            _displayBody(cmd.body, builder);\n            builder.add(\"}\");\n            return;\n        case \"switch\":\n            builder.add(\"switch \").add(_displayExpr(cmd.condition)).add(\" {\").break();\n            builder.indent();\n            try {\n                for (var _b = tslib_1.__values(cmd.cases), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var c = _c.value;\n                    builder.add('case ').add(_displayExpr(c.cond)).add(':').break();\n                    _displayBody(c.body, builder);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            builder.push('}').dedent();\n            return;\n    }\n}\n/**\n * Convert an AST expression to a program string\n * @param expr\t\tThe expression to display as a string\n * @param brackets\tAdd brackets around this expression.\n * \t\t\t\t\tThis setting is ignored (treated false) if the expression is `nil` or an identifier.\n * @returns\t{string} The expression as a strings\n * @private\n */\nfunction _displayExpr(expr, brackets) {\n    var res;\n    switch (expr.type) {\n        case \"identName\":\n            res = expr.value;\n            break;\n        case \"operation\":\n            res = expr.op.value + \" \" + expr.args.map(function (c) { return _displayExpr(c, expr.args.length > 1); }).join(' ');\n            break;\n        case \"equal\":\n            res = _displayExpr(expr.arg1) + \" = \" + expr.arg2;\n            break;\n        case \"list\":\n            res = \"[\" + expr.elements.map(function (c) { return _displayExpr(c); }).join(', ') + \"]\";\n            break;\n        case \"tree_expr\":\n            res = \"<\" + _displayExpr(expr.left) + \".\" + _displayExpr(expr.right) + \">\";\n            break;\n        case \"tree\":\n            res = _displayTree(expr.tree);\n            break;\n        case \"macro\":\n            res = \"<\" + expr.program + \"> \" + _displayExpr(expr.input);\n            break;\n    }\n    //Only add brackets if requested, and if the expression is complex enough to need them\n    if (!brackets\n        || expr.type === 'identName'\n        || expr.type === 'tree' && expr.tree === null)\n        return res;\n    //Wrap the produced string in parentheses\n    return '(' + res + ')';\n}\n/**\n * Convert a binary tree to a program string representation.\n * By default, trees are displayed as cons operations.\n * @param tree\t\tThe list of commands to convert\n * @param pre\t\tThe string to use to \"open\" a tree\n * @param sep\t\tThe string to use to separate the two tree nodes\n * @param post\t\tThe string to use to \"close\" the tree\n * @example {@code displayTree(tn(5), '<', '.', '>')}\tDisplays the tree in <a.b> format\n * @returns {string}\tThe tree as a string\n * @private\n */\nfunction _displayTree(tree, pre, sep, post) {\n    if (pre === void 0) { pre = 'cons '; }\n    if (sep === void 0) { sep = ' '; }\n    if (post === void 0) { post = ''; }\n    if (tree === null)\n        return 'nil';\n    var res = '';\n    //Go depth-first through the tree building up the string\n    var stack = [[tree, false]];\n    while (stack.length) {\n        var _a = tslib_1.__read(stack.pop(), 2), tree_1 = _a[0], isRight = _a[1];\n        if (tree_1 === null) {\n            //Display the nil node\n            res += 'nil';\n            //Close the tree if required\n            if (isRight)\n                res += post;\n            //Otherwise add the separator\n            else\n                res += sep;\n        }\n        else {\n            //Open a new tree\n            res += pre;\n            //Convert the left side before the right side\n            stack.push([tree_1.right, true]);\n            stack.push([tree_1.left, false]);\n        }\n    }\n    return res;\n}\n//# sourceMappingURL=displayProg.js.map","import { BinaryTree, Interpreter } from \"whilejs\";\nimport { treeParser } from \"@whide/tree-lang\";\nimport {\n\tErrorResponse,\n\tLoadedResponse,\n\tLoadRequest,\n\tProgFinishResponse,\n\tWhileWorkerResponse\n} from \"./WhileJsWorkerTypes\";\nimport { AST_PROG } from \"whilejs/lib/types/ast\";\n\nfunction _emit(data: WhileWorkerResponse): void {\n\t(self as any as Worker).postMessage(data);\n}\nfunction _emitErr(msg: string): void {\n\tconst res: ErrorResponse = {\n\t\ttype: 'error',\n\t\tmsg,\n\t};\n\t_emit(res);\n}\nfunction _emitDone(tree: BinaryTree) {\n\tconst msg: ProgFinishResponse = {\n\t\ttype: 'end',\n\t\tres: tree,\n\t};\n\t_emit(msg);\n}\nfunction _emitLoaded() {\n\tconst msg: LoadedResponse = {\n\t\ttype: 'loaded',\n\t};\n\t_emit(msg);\n}\n\nlet interpreter: Interpreter|undefined = undefined;\n\n// We send a message back to the main thread\n(self as any as Worker).addEventListener(\"message\", (event) => {\n\tif (event.data.op === 'load') {\n\t\t//Typed reference to the passed data\n\t\tlet req: LoadRequest = event.data;\n\n\t\t//Parse the provided tree to an object\n\t\tlet prog: AST_PROG = req.prog;\n\t\tlet macros: AST_PROG[] = req.macros;\n\t\tlet tree: BinaryTree;\n\t\ttry {\n\t\t\ttree = treeParser(req.tree);\n\t\t} catch (e) {\n\t\t\t_emitErr(e);\n\t\t\treturn;\n\t\t}\n\t\t//Store the interpreter object for running\n\t\tinterpreter = new Interpreter(prog, tree, {macros: macros});\n\t\t//Emit the loaded event\n\t\t_emitLoaded();\n\t} else if (event.data.op === 'run') {\n\t\t//Check an interpreter has been created\n\t\tif (!interpreter) {\n\t\t\t_emitErr('No program loaded');\n\t\t} else {\n\t\t\t//Run the program and emit the output value\n\t\t\tlet output: BinaryTree = interpreter.run();\n\t\t\t_emitDone(output);\n\t\t}\n\t} else {\n\t\t_emitErr(`Unknown request operation: '${event.data.op}'`);\n\t}\n});","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VariableManager = void 0;\nvar tslib_1 = require(\"tslib\");\nvar NameGenerator_1 = tslib_1.__importDefault(require(\"./NameGenerator\"));\n/**\n * Handle the renaming of variables.\n * Use {@link VariableNamespaceManager.add} to create new variable name/value mappings,\n * and {@link VariableNamespaceManager.name} or {@link VariableNamespaceManager.index} to read existing ones.\n *\n * Namespaces are used to allow merging multiple programs where variable names may overlap.\n * Simply pass a string unique to each program to define groups of variable names.\n *\n * NOTE: Namespaces must be unique to EACH OCCURRENCE of a program merge.\n * This means the same program being merged twice in the same parent program MUST HAVE DIFFERENT NAMESPACES.\n * Duplicate namespaces carry the risk of overlapping variable names, and causing unexpected program results.\n * You may use {@link VariableNamespaceManager.getNewNamespace} to generate unique namespace names.\n * The default namespace name is stored in {@link VariableNamespaceManager.DEFAULT_NS}; passing this as a namespace parameter is\n * treated the same as passing {@code undefined} in its place\n */\nvar VariableNamespaceManager = /** @class */ (function () {\n    /**\n     * @param opts\t\tConstructor options\n     */\n    function VariableNamespaceManager(opts) {\n        this._variableMap = new Map();\n        this._variableLookup = new Map();\n        this._varNameGenerator = new NameGenerator_1.default(opts === null || opts === void 0 ? void 0 : opts.minVarLen);\n        this._namespaceGenerator = new NameGenerator_1.default();\n    }\n    /**\n     * Add a variable to the manager, optionally renaming it to avoid overwriting existing variables.\n     *\n     * @param name\t\t\tThe existing name of the variable to add\n     * \t\t\t\t\t\tNew unique name will be assigned automatically if not provided.\n     * @param namespace\t\t(Optional) The namespace to add this variable under.\n     * \t\t\t\t\t\tDefault is {@code \"default\"}.\n     * @param newName\t\t(Optional) The new name to assign to this variable.\n     * \t\t\t\t\t\tIf not provided, a new unique name will be generated\n     * @param force\t\t\tForce overwriting a variable if the old name already exists in the store..\n     * @return {string}\tThe variable's new name.\n     * \t\t\t\t\tThe stored name when the variable exists in the store,\n     * \t\t\t\t\t{@code newName} if provided, or a new name otherwise otherwise.\n     */\n    VariableNamespaceManager.prototype.add = function (name, namespace, newName, force) {\n        if (namespace === void 0) { namespace = VariableNamespaceManager.DEFAULT_NS; }\n        if (force === void 0) { force = false; }\n        namespace = namespace || VariableNamespaceManager.DEFAULT_NS;\n        //Create a new name if one is not defined\n        if (newName === undefined) {\n            newName = this.getNextVarName();\n        }\n        //Get the namespace's variable map\n        var variables = this._variableMap.get(namespace);\n        if (!variables)\n            this._variableMap.set(namespace, (variables = new VariableManager()));\n        //Return the new name if it has already been set\n        //Unless setting the new value is forced\n        if (variables.exists(name)) {\n            if (!force)\n                return variables.name(name);\n            this._variableLookup.delete(variables.name(name));\n            variables.remove(name);\n        }\n        //Assign and return the variable's new name\n        variables.add(name, newName);\n        this._variableLookup.set(newName, [name, namespace]);\n        return newName;\n    };\n    /**\n     * Add a variable to the manager, and automatically assign it a name\n     * @param val\t\tNumerical value representing the variable\n     * @param namespace\t(Optional) Namespace to add the variable to.\n     * \t\t\t\t\tDefaults to {@link VariableNamespaceManager.DEFAULT_NS}\n     */\n    VariableNamespaceManager.prototype.addAnonymous = function (val, namespace) {\n        if (namespace === void 0) { namespace = VariableNamespaceManager.DEFAULT_NS; }\n        namespace = namespace || VariableNamespaceManager.DEFAULT_NS;\n        var variables = this._variableMap.get(namespace);\n        if (!variables)\n            this._variableMap.set(namespace, (variables = new VariableManager()));\n        if (variables.exists(val))\n            return variables.name(val);\n        var name = this.getNextVarName();\n        this.add(name, namespace, name);\n        return name;\n    };\n    /**\n     * Get the new name of a variable from it's namespace and old name.\n     * @deprecated\tUse {@link name} instead\n     * @param name\t\t\tThe variable's old name\n     * @param namespace\t\t(Optional) The namespace in which to look for the variable.\n     * \t\t\t\t\t\tDefault is {@code \"default\"}.\n     * @returns {string}\tThe new name of the variable, if defined\n     * @returns {undefined}\tIf the variable has not been assigned a name\n     */\n    VariableNamespaceManager.prototype.get = function (name, namespace) {\n        if (namespace === void 0) { namespace = VariableNamespaceManager.DEFAULT_NS; }\n        return this.name(name, namespace);\n    };\n    /**\n     * Get the new name of a variable from it's namespace and old name.\n     * @param name\t\t\tThe variable's old name\n     * @param namespace\t\t(Optional) The namespace in which to look for the variable.\n     * \t\t\t\t\t\tDefault is {@code \"default\"}.\n     * @returns {string}\tThe new name of the variable, if defined\n     * @returns {undefined}\tIf the variable has not been assigned a name\n     */\n    VariableNamespaceManager.prototype.name = function (name, namespace) {\n        var _a;\n        if (namespace === void 0) { namespace = VariableNamespaceManager.DEFAULT_NS; }\n        return (_a = this._variableMap.get(namespace || VariableNamespaceManager.DEFAULT_NS)) === null || _a === void 0 ? void 0 : _a.name(name);\n    };\n    /**\n     * Get the numerical value of a variable from it's namespace and old name.\n     * @param name\t\t\tThe variable's old name\n     * @param namespace\t\t(Optional) The namespace in which to look for the variable.\n     * \t\t\t\t\t\tDefault is {@code \"default\"}.\n     * @returns {string}\tThe new name of the variable, if defined\n     * @returns {undefined}\tIf the variable has not been assigned a name\n     */\n    VariableNamespaceManager.prototype.index = function (name, namespace) {\n        var _a;\n        if (namespace === void 0) { namespace = VariableNamespaceManager.DEFAULT_NS; }\n        return (_a = this._variableMap.get(namespace || VariableNamespaceManager.DEFAULT_NS)) === null || _a === void 0 ? void 0 : _a.index(name);\n    };\n    /**\n     * Delete a variable from its namespace\n     * @param name\t\t\tThe variable's old/current name\n     * @param namespace\t\t(Optional) The namespace from which to delete the variable.\n     * \t\t\t\t\t\tDefault is {@link VariableManager.DEFAULT_NS}.\n     */\n    VariableNamespaceManager.prototype.delete = function (name, namespace) {\n        if (namespace === void 0) { namespace = VariableNamespaceManager.DEFAULT_NS; }\n        var variables = this._variableMap.get(namespace || VariableNamespaceManager.DEFAULT_NS);\n        if (!variables)\n            return;\n        this._variableLookup.delete(variables.name(name));\n        variables.remove(name);\n    };\n    /**\n     * Remove a namespace and all the variables contained in it.\n     * @param namespace\t\t(Optional) The namespace to remove.\n     * \t\t\t\t\t\tDefault is {@link VariableManager.DEFAULT_NS}.\n     */\n    VariableNamespaceManager.prototype.deleteNamespace = function (namespace) {\n        var e_1, _a;\n        if (namespace === void 0) { namespace = VariableNamespaceManager.DEFAULT_NS; }\n        var mgr = this._variableMap.get(namespace || VariableNamespaceManager.DEFAULT_NS);\n        try {\n            for (var _b = tslib_1.__values((mgr === null || mgr === void 0 ? void 0 : mgr.variables) || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                mgr.remove(v[0]);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        this._variableMap.delete(namespace);\n    };\n    /**\n     * Check whether the variable name exists in the map under a given namespace.\n     * @param name\t\t\tThe name of the variable to check\n     * @param namespace\t\t(Optional) The namespace in which to look for the variable.\n     * \t\t\t\t\t\tDefault is {@code \"default\"}.\n     * @returns {true}\tIf the variable exists in the given namespace\n     * @returns {false}\tOtherwise\n     */\n    VariableNamespaceManager.prototype.exists = function (name, namespace) {\n        if (namespace === void 0) { namespace = VariableNamespaceManager.DEFAULT_NS; }\n        return this.name(name, namespace || VariableNamespaceManager.DEFAULT_NS) !== undefined;\n    };\n    /**\n     * Check whether the namespace exists in the map.\n     * @param namespace\t\tThe namespace in which to look for the variable.\n     * \t\t\t\t\t\tDefault is {@code \"default\"}.\n     * @returns {true}\tIf the variable exists in the given namespace\n     * @returns {false}\tOtherwise\n     */\n    VariableNamespaceManager.prototype.namespaceExists = function (namespace) {\n        return this._variableMap.has(namespace);\n    };\n    Object.defineProperty(VariableNamespaceManager.prototype, \"variables\", {\n        /**\n         * Collection of all the new variable names in the program.\n         */\n        get: function () {\n            return new Set(this._variableLookup.keys());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Lookup a variable's namespace and original name from its new name.\n     * @returns {[string, string]}\tThe variable's old name and namespace, respectively.\n     * @returns {undefined}\tIf the variable name has not been assigned\n     */\n    VariableNamespaceManager.prototype.lookupVariable = function (name) {\n        return this._variableLookup.get(name);\n    };\n    Object.defineProperty(VariableNamespaceManager.prototype, \"namespaces\", {\n        /**\n         * Collection of all the namespaces which have been defined in the program.\n         */\n        get: function () {\n            return this._variableMap.keys();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Get a name for a new namespace which won't overlap with any existing ones.\n     */\n    VariableNamespaceManager.prototype.getNewNamespace = function () {\n        var name;\n        do {\n            name = this._varNameGenerator.next();\n        } while (this._variableLookup.has(name));\n        return name;\n    };\n    /**\n     * Get the next variable name which has not already been used by the program.\n     */\n    VariableNamespaceManager.prototype.getNextVarName = function () {\n        var name;\n        do {\n            name = this._varNameGenerator.next();\n        } while (this._variableLookup.has(name));\n        return name;\n    };\n    VariableNamespaceManager.DEFAULT_NS = 'default';\n    return VariableNamespaceManager;\n}());\nexports.default = VariableNamespaceManager;\n/**\n * Class to convert variables to numerical equivalents\n */\nvar VariableManager = /** @class */ (function () {\n    function VariableManager() {\n        this._variables = [];\n        this._names = [];\n        this._ptr = 0;\n    }\n    /**\n     * Assign a variable to a value.\n     * @param variable\tThe name of the variable\n     * @param name\t\t(Optional) New name to assign to the variable.\n     * \t\t\t\t\tDefaults to the variable's current name\n     * @param val\t\t(Optional) Value to assign to the variable.\n     * \t\t\t\t\tDefaults to the next available value\n     */\n    VariableManager.prototype.add = function (variable, name, val) {\n        name = name || variable;\n        if (val !== undefined) {\n            this._variables.splice(val, 0, variable);\n            this._names.splice(val, 0, name);\n            return val;\n        }\n        else if (!this.exists(variable)) {\n            var i = this._ptr++;\n            this._variables.splice(i, 0, variable);\n            this._names.splice(i, 0, name);\n            return i;\n        }\n        return this.index(variable);\n    };\n    /**\n     * Unlink a variable from its value\n     * @param variable\tThe variable to unlink\n     */\n    VariableManager.prototype.remove = function (variable) {\n        var index;\n        if (typeof variable === 'number')\n            index = variable;\n        else\n            index = this.index(variable);\n        if (index > -1) {\n            this._variables.splice(index, 1);\n            this._names.splice(index, 1);\n        }\n        return this;\n    };\n    /**\n     * Whether or not a variable exists\n     * @param variable\tThe variable name\n     */\n    VariableManager.prototype.exists = function (variable) {\n        if (typeof variable === 'number')\n            return this._variables[variable] !== undefined;\n        return this.index(variable) > -1;\n    };\n    /**\n     * Get the index (numerical) value of a variable\n     * @param variable\tThe variable name\n     */\n    VariableManager.prototype.index = function (variable) {\n        return this._variables.indexOf(variable);\n    };\n    /**\n     * Get the index (numerical) value of a variable\n     * @param variable\tThe variable name\n     */\n    VariableManager.prototype.name = function (variable) {\n        var index;\n        if (typeof variable === 'number')\n            index = variable;\n        else\n            index = this._variables.indexOf(variable);\n        return this._names[index];\n    };\n    Object.defineProperty(VariableManager.prototype, \"variables\", {\n        /**\n         * List of all the variables, in order\n         */\n        get: function () {\n            var _this = this;\n            return this._names.map(function (v, i) { return [v, _this._names[i]]; });\n            // return this._variables.map((v,i) => [v, this._names[i]]);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return VariableManager;\n}());\nexports.VariableManager = VariableManager;\n//# sourceMappingURL=VariableManager.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar lexer_1 = require(\"../converter/lexer\");\nvar TreeLexer_1 = require(\"./TreeLexer\");\nvar parser_1 = require(\"../utils/parser\");\nvar ParserException_1 = __importDefault(require(\"../exceptions/ParserException\"));\n/**\n * Convert an integer to a binary tree\n * @param num\tThe number to convert\n */\nfunction _numberToTree(num) {\n    var res = null;\n    while (num > 0) {\n        num--;\n        res = {\n            left: null,\n            right: res,\n        };\n    }\n    return res;\n}\n/**\n * Produce a tree from a literal tree declaration (\"<tree.tree>\")\n * @param tokens\tThe token list\n */\nfunction _interpretTree(tokens) {\n    //Parse the left tree\n    var left = _tokensToTree(tokens);\n    //Check for the dot separating the subtrees\n    parser_1._expect(tokens, lexer_1.TKN_DOT);\n    //Parse the right tree\n    var right = _tokensToTree(tokens);\n    //Check the opening symbol has a matching closing symbol\n    parser_1._expect(tokens, lexer_1.TKN_TREE_CLS);\n    //Return the created tree\n    return {\n        left: left,\n        right: right,\n    };\n}\n/**\n * Produce a list from a list of tokens\n * @param tokens\tThe token list\n */\nfunction _interpretList(tokens) {\n    //If the list is empty, return just the terminator `nil`\n    if (tokens[0] === lexer_1.TKN_LIST_CLS) {\n        tokens.shift();\n        return null;\n    }\n    //Pointers to the top and bottom of the binary tree\n    //So the tree can be built downwards (in-order)\n    var head = {\n        //Parse the first node immediately\n        left: _tokensToTree(tokens),\n        right: null,\n    };\n    var tail = head;\n    //Keep parsing the list until a terminator symbol (']') is found\n    //There must be a separator (`,`) between each element\n    while (parser_1._expect(tokens, lexer_1.TKN_COMMA, lexer_1.TKN_LIST_CLS) === lexer_1.TKN_COMMA) {\n        //Add the next element to the end of the tree\n        tail.right = {\n            left: _tokensToTree(tokens),\n            right: null,\n        };\n        //Move the tail pointer down the tree\n        tail = tail.right;\n    }\n    //Return the produced tree\n    return head;\n}\n/**\n * Parse a token list into a tree node\n * @param tokenList\tThe list of tokens\n */\nfunction _tokensToTree(tokenList) {\n    //Require the first token to be '<' or 'nil'\n    var token = parser_1._expect(tokenList);\n    //Convert numbers directly to numbers\n    if (typeof token === \"number\")\n        return _numberToTree(token);\n    switch (token) {\n        case 'nil':\n        case TreeLexer_1.TKN_FALSE:\n            return _numberToTree(0);\n        case TreeLexer_1.TKN_TRUE:\n            return _numberToTree(1);\n        //Accept binary trees\n        case lexer_1.TKN_TREE_OPN:\n            return _interpretTree(tokenList);\n        //Accept lists\n        case lexer_1.TKN_LIST_OPN:\n            return _interpretList(tokenList);\n        //Accept the programs-as-data atoms using the HWhile numerical representations\n        case TreeLexer_1.TKN_ASSIGN:\n        case TreeLexer_1.TKN_ASSIGN_1:\n            return _numberToTree(2);\n        case TreeLexer_1.TKN_DO_ASSIGN:\n            return _numberToTree(3);\n        case TreeLexer_1.TKN_WHILE:\n            return _numberToTree(5);\n        case TreeLexer_1.TKN_DO_WHILE:\n            return _numberToTree(7);\n        case TreeLexer_1.TKN_IF:\n            return _numberToTree(11);\n        case TreeLexer_1.TKN_DO_IF:\n            return _numberToTree(13);\n        case TreeLexer_1.TKN_VAR:\n            return _numberToTree(17);\n        case TreeLexer_1.TKN_QUOTE:\n            return _numberToTree(19);\n        case TreeLexer_1.TKN_HD:\n            return _numberToTree(23);\n        case TreeLexer_1.TKN_DO_HD:\n            return _numberToTree(29);\n        case TreeLexer_1.TKN_TL:\n            return _numberToTree(31);\n        case TreeLexer_1.TKN_DO_TL:\n            return _numberToTree(37);\n        case TreeLexer_1.TKN_CONS:\n            return _numberToTree(41);\n        case TreeLexer_1.TKN_DO_CONS:\n            return _numberToTree(43);\n        //Error otherwise\n        default:\n            throw parser_1._unexpectedToken(token);\n    }\n}\n/**\n * Parse a token list into a binary tree\n * @param tokenList\t\tThe token list to parse\n */\nfunction parse(tokenList) {\n    //Treat an empty token list as `nil`\n    if (tokenList.length === 0)\n        return null;\n    //Parse into a binary tree\n    var tree = _tokensToTree(tokenList);\n    //Shouldn't be any unparsed tokens\n    if (tokenList.length > 0) {\n        throw new ParserException_1.default(\"Unexpected token: Expected end of statement but got '\" + tokenList.shift() + \"'\");\n    }\n    //Return the tree\n    return tree;\n}\nexports.default = parse;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ErrorManager = void 0;\nvar tslib_1 = require(\"tslib\");\n/**\n * Manager object to simplify the process of creating multiple errors at locations in the input code\n */\nvar ErrorManager = /** @class */ (function () {\n    function ErrorManager() {\n        this._errors = [];\n    }\n    Object.defineProperty(ErrorManager.prototype, \"errors\", {\n        /**\n         * List of all the errors added to this object\n         */\n        get: function () {\n            return this._errors;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Add an error to the list\n     * @param position\tThe position of the error in the program\n     * @param endPos\tThe end position of the error in the program\n     * @param message\tMessage describing the error\n     */\n    ErrorManager.prototype.addError = function (position, message, endPos) {\n        if (endPos === undefined) {\n            this._errors.push({\n                message: message,\n                position: tslib_1.__assign({}, position)\n            });\n        }\n        else {\n            this._errors.push({\n                message: message,\n                position: tslib_1.__assign({}, position),\n                endPos: tslib_1.__assign({}, endPos)\n            });\n        }\n        return this;\n    };\n    return ErrorManager;\n}());\nexports.ErrorManager = ErrorManager;\n//# sourceMappingURL=errorManager.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ProgramManager_1 = tslib_1.__importDefault(require(\"./ProgramManager\"));\n/**\n * Manager class to simplify the loading of macro programs.\n * Automatically detects macro calls from programs and detects whether macros have already been registered.\n */\nvar MacroManager = /** @class */ (function () {\n    function MacroManager(prog, name) {\n        this._unregistered = new Set();\n        this._macroMap = new Map();\n        if (prog)\n            this.register(prog, name);\n    }\n    /**\n     * Register a macro name and AST, automatically detecting any macros registered by those programs.\n     * @param prog\tThe AST of the macro\n     * @param name\t(Optional) Explicit name to use for the macro.\n     * \t\t\t\tIf not provided, the program's name is used.\n     */\n    MacroManager.prototype.register = function (prog, name) {\n        var e_1, _a;\n        //Use the program name if an explicit name is not defined\n        if (!name)\n            name = prog.name.value;\n        //Add the macro to the save list\n        this._macroMap.set(name, {\n            n: name,\n            p: prog\n        });\n        this._unregistered.delete(name);\n        //Get all the macros referenced by this program\n        var mgr = new ProgramManager_1.default(prog);\n        try {\n            for (var _b = tslib_1.__values(mgr.macros), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var macroName = _c.value;\n                //Save the macro to the unregistered list if it has not been registered already\n                if (!this._macroMap.has(macroName)) {\n                    this._unregistered.add(macroName);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    Object.defineProperty(MacroManager.prototype, \"macroNames\", {\n        /**\n         * Names of all the macros stored in the manager.\n         */\n        get: function () {\n            return this._macroMap.keys();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MacroManager.prototype, \"macros\", {\n        /**\n         * Name/AST pairs of all the registered macros in this manager.\n         */\n        get: function () {\n            return Array.from(this._macroMap.values());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MacroManager.prototype, \"unregisteredMacros\", {\n        /**\n         * Names of all the detected macros which don't have an assigned AST\n         */\n        get: function () {\n            return Array.from(this._unregistered);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MacroManager.prototype, \"hasUnregistered\", {\n        /**\n         * Returns {@code true} if there are any macros which don't have an associated AST.\n         */\n        get: function () {\n            return this._unregistered.size > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Get the name of the next macro that has not yet been registered.\n     * @returns {string}\tThe next name of a macro that needs to be registered.\n     * @returns {null}\t\tIf all the macros have been registered.\n     */\n    MacroManager.prototype.getNextUnregistered = function () {\n        var next;\n        while (true) {\n            //Make sure there is an iterator of the unregistered macros\n            if (this._unregistered.size === 0)\n                return null;\n            if (!this._iterator)\n                this._iterator = this._unregistered.values();\n            //Get the next unregistered name from the iterator\n            next = this._iterator.next();\n            //Remove the iterator if it has finished\n            if (next.done)\n                this._iterator = undefined;\n            //Check if the macro has been registered\n            if (!this._macroMap.has(next.value))\n                return next.value;\n        }\n    };\n    /**\n     * Use a callback to automatically load and register macro programs until all are loaded.\n     * @param cbk\tCallback function to load a macro program given the macro name.\n     * \t\t\t\tInput parameter is the macro name.\n     * \t\t\t\tReturn value is an {@link AST_PROG}\tobject, or an {@link MacroDescriptor} object specifying a name.\n     */\n    MacroManager.prototype.autoRegister = function (cbk) {\n        //Run until all macros are registered\n        while (this.hasUnregistered) {\n            //Get the next referenced macro\n            var macroName = this.getNextUnregistered();\n            //Use the callback to load the macro\n            var res = cbk(macroName);\n            //Register\n            this.register(res, macroName);\n        }\n    };\n    return MacroManager;\n}());\nexports.default = MacroManager;\n//# sourceMappingURL=MacroManager.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.treeParser = exports.stringify = void 0;\nvar converter_1 = __importDefault(require(\"./converter/converter\"));\nvar lexer_1 = __importDefault(require(\"./converter/lexer\"));\nvar parser_1 = __importDefault(require(\"./converter/parser\"));\nvar stringify_1 = __importDefault(require(\"./stringify\"));\nexports.stringify = stringify_1.default;\nvar TreeLexer_1 = __importDefault(require(\"./trees/TreeLexer\"));\nvar TreeParser_1 = __importDefault(require(\"./trees/TreeParser\"));\nfunction _runParse(conversionString) {\n    //First lex the input into tokens\n    var tokens = lexer_1.default(conversionString);\n    //Then parse the result into a ConversionTree\n    return parser_1.default(tokens);\n}\n/**\n * Convert a string to a binary tree\n * @param str\t\tThe string to parse into a binary tree\n * @returns\t{@link BinaryTree} object representing the string\n */\nfunction treeParser(str) {\n    //Run the lexer to convert to a token list\n    var tokenList = TreeLexer_1.default(str);\n    //Parse into a binary tree\n    return TreeParser_1.default(tokenList);\n}\nexports.treeParser = treeParser;\n/**\n * Convert a binary tree using the provided conversion string\n * @param tree\t\t\t\tThe tree to convert\n * @param conversionString\tThe conversion string to use\n * @param customAtoms\t\tCustom atomic values to extend the language.\n * \t\t\t\t\t\t\tRepresented in {@code atomName:conversionString} format.\n * \t\t\t\t\t\t\t(e.g. {@code \"mybool\": \"true|false\"})\n * @returns\t\tObject containing the result of the conversion\n */\nfunction default_1(tree, conversionString, customAtoms) {\n    //Parse the conversion string into a ConversionTree\n    var parseResult = _runParse(conversionString);\n    //Parse each of the custom atoms into a ConversionTree\n    customAtoms = customAtoms || new Map();\n    var atoms = new Map();\n    customAtoms.forEach(function (converter, name) {\n        var parseResult = _runParse(converter);\n        atoms.set(name, parseResult);\n    });\n    //Finally perform the conversion\n    return converter_1.default(tree, parseResult, atoms);\n}\nexports.default = default_1;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LexerException = /** @class */ (function (_super) {\n    __extends(LexerException, _super);\n    function LexerException(message) {\n        return _super.call(this, message) || this;\n    }\n    return LexerException;\n}(Error));\nexports.default = LexerException;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction _idnt(value) {\n    return {\n        type: 'identName',\n        value: value\n    };\n}\nfunction _assign(ident, value) {\n    if (typeof value === 'string')\n        value = _idnt(value);\n    return {\n        type: 'assign',\n        complete: true,\n        ident: _idnt(ident),\n        arg: value,\n    };\n}\nfunction _operation(op) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    args = args.map(function (v) { return (typeof v === 'string') ? _idnt(v) : v; });\n    return {\n        type: 'operation',\n        complete: true,\n        op: { type: 'opToken', value: op },\n        args: args,\n    };\n}\nfunction _while(cond, body) {\n    return {\n        type: 'loop',\n        complete: true,\n        condition: cond,\n        body: body,\n    };\n}\nfunction _if(cond, bodyIf, bodyElse) {\n    if (bodyElse === void 0) { bodyElse = []; }\n    return {\n        type: 'cond',\n        complete: true,\n        condition: cond,\n        if: bodyIf,\n        else: bodyElse,\n    };\n}\nvar nil_token = _idnt('nil');\nvar false_token = nil_token;\nvar true_token = {\n    type: 'operation',\n    complete: true,\n    op: { type: 'opToken', value: 'cons' },\n    args: [nil_token, nil_token]\n};\nvar EQUALS_PROG = {\n    type: 'program',\n    complete: true,\n    // equals\n    name: _idnt('equals'),\n    // read TS {\n    input: _idnt('TS'),\n    body: [\n        // s := cons TS nil;\n        _assign('s', _operation('cons', 'TS', nil_token)),\n        // isEqual := true;\n        _assign('isEqual', true_token),\n        // while s {\n        _while(_idnt('s'), [\n            // t1 := hd hd s;\n            _assign('t1', _operation('hd', _operation('hd', 's'))),\n            // t2 := tl hd s;\n            _assign('t2', _operation('tl', _operation('hd', 's'))),\n            // s := tl s;\n            _assign('s', _operation('tl', 's')),\n            // if t1 {\n            _if(_idnt('t1'), [\n                // if t2 {\n                _if(_idnt('t2'), [\n                    // s := cons (cons (tl t1) (tl t2)) s;\n                    _assign('s', _operation('cons', _operation('cons', _operation('tl', 't1'), _operation('tl', 't2')), 's')),\n                    // s := cons (cons (hd t1) (hd t2)) s;\n                    _assign('s', _operation('cons', _operation('cons', _operation('hd', 't1'), _operation('hd', 't2')), 's')),\n                    // } else {\n                ], [\n                    // isEqual := false\n                    _assign('isEqual', false_token),\n                    // s := nil\n                    _assign('s', nil_token)\n                ]),\n                // } else {\n            ], [\n                // if t2 {\n                _if(_idnt('t2'), [\n                    // isEqual := false\n                    _assign('isEqual', false_token),\n                    // s := nil\n                    _assign('s', nil_token)\n                    // }\n                ])\n            ]),\n            // }\n        ]),\n    ],\n    // } write isEqual\n    output: _idnt('isEqual'),\n};\nexports.default = EQUALS_PROG;\n/*\n(*\nPure WHILE program to check the equality of two binary trees using depth-first traversal.\nInput is of the form <T.S> where `T` and `S` are the two trees to compare.\nOutput is true (<nil.nil>) if the trees are equal, or false (nil) otherwise.\n\nAt the start of each iteration, each element of the stack 's' is two trees (<t1.t2>) which are in equivalent positions\nin the two input trees.\nInitially, the stack contains one element, which is the two input trees to the macro.\n\nFor each iteration, the trees held at the top of the stack are checked for equality.\nIf one is nil and the other is not, the loop exits and returns that the trees are not equal.\nIf they are both non-nil, each tree's right-node is added to the stack, then each tree's left-node.\nThis results in a depth-first traversal of the nodes in the trees, travelling down the leftmost path first,\nthen working back up until the rightmost node is reached.\n*)\n\nmyequals read TS {\n    //Initialise a stack to hold the two input trees to compare\n    s := cons TS nil;\n\n    //Hold whether or not a difference has been found in the trees\n    isEqual := true;\n\n    //Loop for as long as there are untraversed nodes in the trees\n    while s {\n        //Pop the next subtrees to compare from the stack\n        t1 := hd hd s;\n        t2 := tl hd s;\n        s := tl s;\n\n        if t1 {\n            if t2 {\n                // t1 and t2 are both not nil\n\n                // Add the right-side subtrees to the stack\n                s := cons (cons (tl t1) (tl t2)) s;\n                // Add the left-side subtrees to the stack\n                s := cons (cons (hd t1) (hd t2)) s;\n            } else {\n                //t2 is nil and t1 is not\n                //Mark the trees as different and stop looping\n                isEqual := false;\n                s := nil\n            }\n        } else {\n            if t2 {\n                //t1 is nil and t2 is not\n                //Mark the trees as different and stop looping\n                isEqual := false;\n                s := nil\n            }\n            //Otherwise subtrees are both nil\n        }\n    }\n} write isEqual\n*/ \n//# sourceMappingURL=astEquals.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar lexer_1 = tslib_1.__importDefault(require(\"../linter/lexer\"));\nvar parser_1 = tslib_1.__importDefault(require(\"../linter/parser\"));\n/**\n * An interpreter for a WHILE program.\n */\nvar Interpreter = /** @class */ (function () {\n    /**\n     * @param ast\tAST of the program, as produced by the while parser\n     * @param input\tBinary tree to pass as input to the program\n     * @param props\tInitialisation configuration parameters\n     */\n    function Interpreter(ast, input, props) {\n        var e_1, _a;\n        this._program = ast;\n        this._input = input;\n        this._props = props || {};\n        this._store = new Map();\n        this._store.set(ast.input.value, input);\n        this._macros = new Map();\n        try {\n            for (var _b = tslib_1.__values((props === null || props === void 0 ? void 0 : props.macros) || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var macro = _c.value;\n                var name_1 = void 0;\n                var prog = void 0;\n                if (macro.p) {\n                    prog = macro.p;\n                    name_1 = macro.n || prog.name.value;\n                }\n                else {\n                    name_1 = macro.name.value;\n                    prog = macro;\n                }\n                this._macros.set(name_1, prog);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        this._exprStack = [];\n        this._commandStack = [{\n                type: 'block',\n                body: tslib_1.__spreadArray([], tslib_1.__read(this._program.body)),\n            }];\n    }\n    /**\n     * Create an Interpreter object from a program string.\n     * The program is parsed, and given to a new Interpreter object if everything succeeded.\n     * @param program\t\tThe program string to run\n     * @param inputTree\t\tInput tree to pass to the program\n     * @param props\t\t\tExtra properties to pass when initialising the Interpreter\n     */\n    Interpreter.parse = function (program, inputTree, props) {\n        var lexerOpts = (props === null || props === void 0 ? void 0 : props.lexOpts) || {};\n        var parseOpts = (props === null || props === void 0 ? void 0 : props.parseOpts) || {};\n        if ((props === null || props === void 0 ? void 0 : props.pureOnly) === true) {\n            lexerOpts.pureOnly = true;\n            parseOpts.pureOnly = true;\n        }\n        //Pass the program through the lexer and parer\n        var _a = tslib_1.__read(lexer_1.default(program, props === null || props === void 0 ? void 0 : props.lexOpts), 2), tokenList = _a[0], lexerErrors = _a[1];\n        var _b = tslib_1.__read(parser_1.default(tokenList, props === null || props === void 0 ? void 0 : props.parseOpts), 2), ast = _b[0], parseErrors = _b[1];\n        //Combine the lexer and parser errors into a single list\n        var errors = tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(lexerErrors)), tslib_1.__read(parseErrors));\n        if (ast.complete) {\n            //Create and return an interpreter\n            return {\n                success: true,\n                interpreter: new Interpreter(ast, inputTree, props)\n            };\n        }\n        //Return the errors if the program couldn't be parsed completely\n        return {\n            success: false,\n            errors: errors,\n        };\n    };\n    /**\n     * Check whether two {@link BinaryTree}s are equal.\n     * That is, they represent the same tree.\n     * Comparing two trees with {@code ===} or {@code ==} may return false even if the trees mean the same thing.\n     * Comparison is done with a depth-first search.\n     * @param s\tThe first tree to compare\n     * @param t\tThe second tree to compare\n     * @returns {@code true} if the two trees are equal\n     */\n    Interpreter.treeEquals = function (s, t) {\n        var sNodes = [s];\n        var tNodes = [t];\n        while (sNodes.length > 0) {\n            //Read the fist node from the stacks\n            var sn = sNodes.shift();\n            var tn = tNodes.shift();\n            //Nodes are equal\n            if (sn === null && tn === null)\n                continue;\n            //Nodes are both trees\n            if (sn !== null && tn !== null) {\n                //Compare the left and right nodes\n                sNodes.push(sn.left, sn.right);\n                tNodes.push(tn.left, tn.right);\n            }\n            else if (sn !== tn) {\n                //One node is a tree, the other isn't\n                //Therefore the trees are different\n                return false;\n            }\n        }\n        //The trees are equal here\n        return true;\n    };\n    /**\n     * Run the program until it has finished executing.\n     * @returns\tBinaryTree\tThe value of the output variable at the end of execution\n     */\n    Interpreter.prototype.run = function () {\n        //Evaluate the command stack from its current state.\n        this._runCommandStack();\n        //Return the output variable value\n        return this._store.get(this._program.output.value) || null;\n    };\n    Object.defineProperty(Interpreter.prototype, \"store\", {\n        get: function () {\n            return this._store;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Interpreter.prototype, \"ast\", {\n        get: function () {\n            return this._program;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Evaluate an expression.\n     * This is hd/tl/cons operations, and reading variable (identifier) values.\n     * These do not affect the variable store.\n     * @param expr\tThe expression to evaluate.\n     * @private\n     */\n    Interpreter.prototype._evalExpr = function (expr) {\n        var exprStack = this._exprStack;\n        exprStack.push({\n            type: 'root',\n            args: [expr]\n        });\n        exprStack.push(Interpreter._copyExpr(expr));\n        this._evalExprStack();\n        //The root expression object will not be popped during evaluation\n        //The expression stack will have been evaluated until the root's argument (the input expression) is evaluated\n        var root = exprStack.pop();\n        //Return the tree\n        return root.args[0].tree;\n    };\n    /**\n     * Evaluate the command stack until it is empty.\n     * @private\n     */\n    Interpreter.prototype._runCommandStack = function () {\n        var e_2, _a;\n        while (this._commandStack.length > 0) {\n            //Read the next command from the top of the stack\n            var op = this._commandStack.pop();\n            if (op.type === \"assign\") {\n                //Evaluate the right-side of the assignment\n                var val = this._evalExpr(op.arg);\n                //Store in the variable\n                this._store.set(op.ident.value, val);\n            }\n            else if (op.type === \"cond\") {\n                //Evaluate the condition\n                if (this._evalExpr(op.condition) !== null) {\n                    //Add the if block to the stack to be executed\n                    this._commandStack.push({\n                        type: 'block',\n                        body: tslib_1.__spreadArray([], tslib_1.__read(op.if))\n                    });\n                }\n                else {\n                    //Add the else block to the stack to be executed\n                    this._commandStack.push({\n                        type: 'block',\n                        body: tslib_1.__spreadArray([], tslib_1.__read(op.else))\n                    });\n                }\n            }\n            else if (op.type === \"loop\") {\n                //Evaluate the condition\n                if (this._evalExpr(op.condition) !== null) {\n                    //Add the loop to the top of the stack so it is checked again later\n                    this._commandStack.push(op);\n                    //Evaluate the loop body once\n                    this._commandStack.push({\n                        type: 'block',\n                        body: tslib_1.__spreadArray([], tslib_1.__read(op.body))\n                    });\n                }\n            }\n            else if (op.type === \"switch\") {\n                //Evaluate the condition\n                var condition = this._evalExpr(op.condition);\n                var caseFound = false;\n                try {\n                    for (var _b = (e_2 = void 0, tslib_1.__values(op.cases)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var cse = _c.value;\n                        var caseCond = this._evalExpr(cse.cond);\n                        if (Interpreter.treeEquals(condition, caseCond)) {\n                            caseFound = true;\n                            //Add the if block to the stack to be executed\n                            this._commandStack.push({\n                                type: 'block',\n                                body: tslib_1.__spreadArray([], tslib_1.__read(cse.body))\n                            });\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                if (!caseFound) {\n                    //Add the if block to the stack to be executed\n                    this._commandStack.push({\n                        type: 'block',\n                        body: tslib_1.__spreadArray([], tslib_1.__read(op.default.body))\n                    });\n                }\n            }\n            else if (op.type === \"block\") {\n                //Read the first command from the block\n                var first = op.body.shift();\n                //Add the block to the stack if it is not finished\n                if (op.body.length > 0)\n                    this._commandStack.push(op);\n                //Add the command to the stack if it exists\n                if (first !== undefined)\n                    this._commandStack.push(first);\n            }\n            else {\n                throw new Error(\"Unexpected operation type '\" + op.type + \"'\");\n            }\n        }\n    };\n    /**\n     * Evaluate the expression stack until it is empty\n     * @private\n     */\n    Interpreter.prototype._evalExprStack = function () {\n        var e_3, _a;\n        var _b, _c;\n        while (this._exprStack.length > 1) {\n            //Read the next expression from the top of the stack\n            var curr = this._exprStack.pop();\n            if (curr.type === \"operation\") {\n                //Check to see if the operation's arguments have all been evaluated\n                var evaled = true;\n                try {\n                    for (var _d = (e_3 = void 0, tslib_1.__values(curr.args)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                        var arg = _e.value;\n                        if (arg.type !== 'literal') {\n                            //If not, add the next one to the top of the stack to be evaluated\n                            this._exprStack.push(curr);\n                            this._exprStack.push(Interpreter._copyExpr(arg));\n                            evaled = false;\n                            break;\n                        }\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n                //If the operation's arguments have all been evaluated\n                //Then evaluate the expression itself using the arguments\n                if (evaled) {\n                    var val = void 0;\n                    var args = curr.args;\n                    switch (curr.op.value) {\n                        case \"cons\":\n                            //Evaluate the left and right arguments\n                            val = {\n                                left: args[0].tree,\n                                right: args[1].tree\n                            };\n                            break;\n                        case \"hd\":\n                            //Return the left side of the tree, using `nil` if the value is already `nil`\n                            val = ((_b = args[0].tree) === null || _b === void 0 ? void 0 : _b.left) || null;\n                            break;\n                        case \"tl\":\n                            //Return the right side of the tree, using `nil` if the value is already `nil`\n                            val = ((_c = args[0].tree) === null || _c === void 0 ? void 0 : _c.right) || null;\n                            break;\n                        default:\n                            //Unknown expression type\n                            throw new Error(\"Unknown operation token '\" + curr.type + \"'\");\n                    }\n                    //Save the value as the first argument of the parent expression\n                    this._replaceArgWithLiteral(val);\n                }\n            }\n            else if (curr.type === \"equal\") {\n                if (curr.arg1.type !== 'literal') {\n                    //Evaluate the first argument if it has not already been done\n                    this._exprStack.push(curr);\n                    this._exprStack.push(Interpreter._copyExpr(curr.arg1));\n                }\n                else if (curr.arg2.type !== 'literal') {\n                    //Evaluate the second argument if it has not already been done\n                    this._exprStack.push(curr);\n                    this._exprStack.push(Interpreter._copyExpr(curr.arg2));\n                }\n                else {\n                    //Evaluate the expression using the arguments\n                    //Save the produced tree in the first free argument of the parent expression\n                    if (Interpreter.treeEquals(curr.arg1.tree, curr.arg2.tree)) {\n                        this._replaceArgWithLiteral({\n                            left: null,\n                            right: null,\n                        });\n                    }\n                    else {\n                        this._replaceArgWithLiteral(null);\n                    }\n                }\n            }\n            else if (curr.type === \"tree_expr\") {\n                if (curr.left.type !== 'literal') {\n                    this._exprStack.push(curr);\n                    this._exprStack.push(Interpreter._copyExpr(curr.left));\n                }\n                else if (curr.right.type !== 'literal') {\n                    this._exprStack.push(curr);\n                    this._exprStack.push(Interpreter._copyExpr(curr.right));\n                }\n                else {\n                    this._replaceArgWithLiteral({\n                        left: curr.left.tree,\n                        right: curr.right.tree,\n                    });\n                }\n            }\n            else if (curr.type === \"identName\") {\n                //Look up the variable in the store, using nil as a fallback\n                this._replaceArgWithLiteral(this._store.get(curr.value) || null);\n            }\n            else if (curr.type === \"tree\") {\n                this._replaceArgWithLiteral(curr.tree);\n            }\n            else if (curr.type === \"list\") {\n                var res = {\n                    type: 'literal',\n                    tree: null\n                };\n                for (var i = curr.elements.length; i >= 0; --i) {\n                    res = {\n                        type: 'tree_expr',\n                        left: curr.elements[i],\n                        right: res,\n                    };\n                }\n                if (res.type === 'literal') {\n                    this._exprStack.push({\n                        type: 'tree',\n                        tree: res.tree\n                    });\n                }\n                else {\n                    this._replaceArgWithLiteral(null);\n                }\n            }\n            else if (curr.type === \"macro\") {\n                if (curr.input.type !== 'literal') {\n                    //Evaluate the macro argument first\n                    this._exprStack.push(curr);\n                    this._exprStack.push(curr.input);\n                }\n                else {\n                    if (!this._macros.has(curr.program)) {\n                        throw new Error(\"Could not find macro \\\"\" + curr.program + \"\\\". Ensure the macro is named correctly and has been passed to the interpreter.\");\n                    }\n                    var interpreter = new Interpreter(this._macros.get(curr.program), curr.input.tree, this._props);\n                    this._replaceArgWithLiteral(interpreter.run());\n                }\n            }\n            else {\n                //Unknown expression type\n                throw new Error(\"Unknown expression token '\" + curr.type + \"'\");\n            }\n        }\n    };\n    /**\n     * Produce a copy of an expression AST node so that it can be modified without affecting the original.\n     * @param expr\tThe expression to copy.\n     * @private\n     */\n    Interpreter._copyExpr = function (expr) {\n        var copy = tslib_1.__assign({}, expr);\n        if (copy.type === 'root' || copy.type === 'operation') {\n            //Recreate the object's argument list to prevent overwriting the original when it's changed\n            copy.args = tslib_1.__spreadArray([], tslib_1.__read(copy.args));\n        }\n        return copy;\n    };\n    /**\n     * Replace the first non-literal argument of the expression at the top of {@link _exprStack} with a literal value.\n     * @param val\tThe literal value to assign in place of the argument\n     */\n    Interpreter.prototype._replaceArgWithLiteral = function (val) {\n        //Read the parent expression from the stack\n        var par = this._exprStack.pop();\n        //Wrap the value as a Literal\n        var literal = {\n            type: 'literal',\n            tree: val\n        };\n        if (par === undefined) {\n            throw new Error(\"Can't assign argument to undefined object\");\n        }\n        else if (par.type === 'operation' || par.type === 'root') {\n            for (var i = 0; i < par.args.length; i++) {\n                //Find the first non-literal argument\n                if (par.args[i].type !== 'literal') {\n                    //Replace it with the value argument\n                    par.args[i] = literal;\n                    //Stop after 1 replace\n                    break;\n                }\n            }\n        }\n        else if (par.type === 'tree_expr') {\n            if (par.left.type !== 'literal') {\n                par.left = literal;\n            }\n            else {\n                par.right = literal;\n            }\n        }\n        else if (par.type === 'equal') {\n            if (par.arg1.type !== 'literal') {\n                par.arg1 = literal;\n            }\n            else {\n                par.arg2 = literal;\n            }\n        }\n        else if (par.type === 'macro') {\n            par.input = literal;\n            // } else if (par.type === 'identifier') {\n        }\n        else {\n            //Unknown/invalid expression type\n            throw new Error(\"Can't assign argument to type '\" + par.type + \"'\");\n        }\n        //Add the parent expression back onto the stack\n        this._exprStack.push(par);\n    };\n    return Interpreter;\n}());\nexports.default = Interpreter;\n//# sourceMappingURL=Interpreter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PAD_VALUES = exports.TKN_PAD_DO_CONS = exports.TKN_PAD_CONS = exports.TKN_PAD_DO_TL = exports.TKN_PAD_TL = exports.TKN_PAD_DO_HD = exports.TKN_PAD_HD = exports.TKN_PAD_QUOTE = exports.TKN_PAD_VAR = exports.TKN_PAD_DO_IF = exports.TKN_PAD_IF = exports.TKN_PAD_DO_WHILE = exports.TKN_PAD_WHILE = exports.TKN_PAD_DO_ASSIGN = exports.TKN_PAD_ASSIGN_1 = exports.TKN_PAD_ASSIGN = exports.TKN_FALSE = exports.TKN_TRUE = exports.TKN_DEFAULT = exports.TKN_CASE = exports.TKN_SWITCH = exports.TKN_COLON = exports.TKN_DOT = exports.TKN_COMMA = exports.TKN_MCRO_CLS = exports.TKN_MCRO_OPN = exports.TKN_LIST_CLS = exports.TKN_LIST_OPN = exports.TKN_EQL = void 0;\nexports.TKN_EQL = '=';\nexports.TKN_LIST_OPN = '[';\nexports.TKN_LIST_CLS = ']';\nexports.TKN_MCRO_OPN = '<';\nexports.TKN_MCRO_CLS = '>';\nexports.TKN_COMMA = ',';\nexports.TKN_DOT = '.';\nexports.TKN_COLON = ':';\nexports.TKN_SWITCH = 'switch';\nexports.TKN_CASE = 'case';\nexports.TKN_DEFAULT = 'default';\nexports.TKN_TRUE = 'true';\nexports.TKN_FALSE = 'false';\nexports.TKN_PAD_ASSIGN = '@asgn';\nexports.TKN_PAD_ASSIGN_1 = '@:=';\nexports.TKN_PAD_DO_ASSIGN = '@doAsgn';\nexports.TKN_PAD_WHILE = '@while';\nexports.TKN_PAD_DO_WHILE = '@doWhile';\nexports.TKN_PAD_IF = '@if';\nexports.TKN_PAD_DO_IF = '@doIf';\nexports.TKN_PAD_VAR = '@var';\nexports.TKN_PAD_QUOTE = '@quote';\nexports.TKN_PAD_HD = '@hd';\nexports.TKN_PAD_DO_HD = '@doHd';\nexports.TKN_PAD_TL = '@tl';\nexports.TKN_PAD_DO_TL = '@doTl';\nexports.TKN_PAD_CONS = '@cons';\nexports.TKN_PAD_DO_CONS = '@doCons';\n//Accept the programs-as-data atoms using the HWhile numerical representations\nexports.PAD_VALUES = {\n    '@asgn': 2,\n    '@:=': 2,\n    '@doAsgn': 3,\n    '@while': 5,\n    '@doWhile': 7,\n    '@if': 11,\n    '@doIf': 13,\n    '@var': 17,\n    '@quote': 19,\n    '@hd': 23,\n    '@doHd': 29,\n    '@tl': 31,\n    '@doTl': 37,\n    '@cons': 41,\n    '@doCons': 43, //TKN_PAD_DO_CONS\n};\n//# sourceMappingURL=extendedTokens.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tokens_1 = require(\"../../types/tokens\");\nvar errorManager_1 = require(\"../../utils/errorManager\");\nvar extendedTokens_1 = require(\"../../types/extendedTokens\");\nvar TreeLexer_1 = require(\"@whide/tree-lang/lib/trees/TreeLexer\");\n/**\n * Convert an identifier token ({@link IDENT_TYPE}) to an AST identifier node.\n * @param ident\tThe identifier token to convert\n */\nfunction astIdent(ident) {\n    return {\n        type: 'identName',\n        value: ident.value,\n    };\n}\n/**\n * Convert an operation token of type {@link OP_TYPE_EXTD} (a 'hd'/'cons'/... token) to an AST operation token node.\n * @param op\tThe operation token to convert\n */\nfunction astOp(op) {\n    return {\n        type: 'opToken',\n        value: op.value,\n    };\n}\n/**\n * Internal representation for the result status of an operation.\n * Provides more information than a null/undefined result.\n */\nvar ParseStatus;\n(function (ParseStatus) {\n    ParseStatus[ParseStatus[\"OK\"] = 0] = \"OK\";\n    ParseStatus[ParseStatus[\"ERROR\"] = 1] = \"ERROR\";\n    ParseStatus[ParseStatus[\"EOI\"] = 2] = \"EOI\";\n})(ParseStatus || (ParseStatus = {}));\nvar ErrorManager = /** @class */ (function (_super) {\n    tslib_1.__extends(ErrorManager, _super);\n    function ErrorManager() {\n        return _super.call(this) || this;\n    }\n    ErrorManager.prototype.unexpectedToken = function (position, endPos, actual) {\n        var expected = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            expected[_i - 3] = arguments[_i];\n        }\n        return this.unexpectedValue.apply(this, tslib_1.__spreadArray([position, endPos, 'token', actual], tslib_1.__read(expected)));\n    };\n    ErrorManager.prototype.unexpectedEOI = function (position, endPos) {\n        var expected = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            expected[_i - 2] = arguments[_i];\n        }\n        return this.unexpectedValue.apply(this, tslib_1.__spreadArray([position, endPos, 'end of input', undefined], tslib_1.__read(expected)));\n    };\n    ErrorManager.prototype.unexpectedValue = function (position, endPos, type, actual) {\n        if (type === void 0) { type = 'token'; }\n        var expected = [];\n        for (var _i = 4; _i < arguments.length; _i++) {\n            expected[_i - 4] = arguments[_i];\n        }\n        var msg = \"Unexpected \" + type;\n        if (expected.length === 0) {\n            if (actual)\n                msg += \": \\\"\" + actual + \"\\\"\";\n        }\n        else {\n            if (actual)\n                msg += \" \\\"\" + actual + \"\\\"\";\n            if (expected.length === 1)\n                msg += \": Expected \\\"\" + expected[0] + \"\\\"\";\n            else\n                msg += \": Expected one of \\\"\" + expected.join(\"\\\", \\\"\") + \"\\\"\";\n        }\n        return this.addError(position, msg, endPos);\n    };\n    return ErrorManager;\n}(errorManager_1.ErrorManager));\n/**\n * Object containing state information for use in parsing.\n * Acts as a queue wrapper around the program token list.\n */\nvar StateManager = /** @class */ (function () {\n    function StateManager(tokens) {\n        this._errorManager = new ErrorManager();\n        this._tokens = tokens;\n        this._lastToken = undefined;\n        this._pos = {\n            col: 0,\n            row: 0,\n        };\n        this._endPos = {\n            col: 0,\n            row: 0,\n        };\n    }\n    Object.defineProperty(StateManager.prototype, \"errorManager\", {\n        /**\n         * Object to manage the produced error messages\n         */\n        get: function () {\n            return this._errorManager;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StateManager.prototype, \"errors\", {\n        /**\n         * All the error messages produced up to this point.\n         *\n         * Wrapper around {@link ErrorManager.errors}\n         */\n        get: function () {\n            return this.errorManager.errors;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Pop a token from the start of the token list, and expect it to match one of the provided expected tokens..\n     * Automatically produces an error if the token is an unexpected value or if the token list ends prematurely.\n     * @param expected\tList of the tokens to accept here.\n     * \t\t\t\t\tEmpty for any token.\n     * @returns {[ParseStatus.OK, WHILE_TOKEN_EXTD]}\tThe next token value from the list, which is one of {@code expected}\n     * @returns {[ParseStatus.ERROR, WHILE_TOKEN_EXTD]}\tThe next token value from the list, which is not one of {@code expected}\n     * @returns {[ParseStatus.EOI, null]}\tNo return token as the list is empty\n     */\n    StateManager.prototype.expect = function () {\n        var e_1, _a;\n        var expected = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            expected[_i] = arguments[_i];\n        }\n        var first = this._next();\n        //Unexpected end of token list\n        if (first === null) {\n            this.unexpectedEOI.apply(this, tslib_1.__spreadArray([], tslib_1.__read(expected)));\n            return [ParseStatus.EOI, null];\n        }\n        //Allow any token if no expected was provided\n        if (expected.length === 0)\n            return [ParseStatus.OK, first];\n        try {\n            //The token matches the expected value\n            for (var expected_1 = tslib_1.__values(expected), expected_1_1 = expected_1.next(); !expected_1_1.done; expected_1_1 = expected_1.next()) {\n                var exp = expected_1_1.value;\n                if (first.value === exp)\n                    return [ParseStatus.OK, first];\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (expected_1_1 && !expected_1_1.done && (_a = expected_1.return)) _a.call(expected_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        //The token is unexpected - add an error\n        this.unexpectedToken.apply(this, tslib_1.__spreadArray([first.value], tslib_1.__read(expected)));\n        return [ParseStatus.ERROR, first];\n    };\n    /**\n     * Get the next token in the token list and remove from the queue.\n     */\n    StateManager.prototype.next = function () {\n        return this._next();\n    };\n    /**\n     * Get the next token in the token list without removing from the queue.\n     * @param pos\tThe position of the token to read from the list.\n     * \t\t\t\tDefault {@code 0} (the first element).\n     * @return {WHILE_TOKEN_EXTD} \tThe next token in the list\n     * @return {null} \t\t\t\tIf the list is empty, or if the position is after the end of the list.\n     */\n    StateManager.prototype.peek = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        if (pos < 0 || pos >= this._tokens.length)\n            return null;\n        return this._tokens[pos];\n    };\n    /**\n     * Read from the token list until one of the expected tokens (or the end of the list) is reached.\n     * The terminating token (EOI or one of {@code expected}) is not popped from the queue.\n     * @param expected\tTokens to look for to break the match\n     * @returns {WHILE_TOKEN_EXTD[]}\tThe tokens popped from the queue\n     */\n    StateManager.prototype.consumeUntil = function () {\n        var e_2, _a;\n        var expected = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            expected[_i] = arguments[_i];\n        }\n        var res = [];\n        var next;\n        while ((next = this.peek()) !== null) {\n            try {\n                for (var expected_2 = (e_2 = void 0, tslib_1.__values(expected)), expected_2_1 = expected_2.next(); !expected_2_1.done; expected_2_1 = expected_2.next()) {\n                    var e = expected_2_1.value;\n                    if (next.value === e)\n                        return res;\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (expected_2_1 && !expected_2_1.done && (_a = expected_2.return)) _a.call(expected_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            res.push(this.next());\n        }\n        return res;\n    };\n    //TODO: Write `consumeUntilMatchingParen` which counts opening/closing brackets of different types.\n    //\tShould accept a starting bracket as param\n    //Errors\n    /**\n     * Add an error message at the current token\n     * @param msg\tThe error message\n     */\n    StateManager.prototype.addError = function (msg) {\n        this._errorManager.addError(this._pos, msg, this._endPos);\n        return this;\n    };\n    /**\n     * Add a generic \"unexpected ??\" message at the current token\n     * @param type\t\tThe type which was unexpected (e.g. 'token')\n     * @param actual\tThe unexpected value\n     * @param expected\tThe expected value(s)\n     * @example\t\t{@code unexpectedValue('number', '10', '20)} -> {@code \"Unexpected number: Expected 20 got 10\"}\n     */\n    StateManager.prototype.unexpectedValue = function (type, actual) {\n        var _a;\n        var expected = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            expected[_i - 2] = arguments[_i];\n        }\n        if (typeof type === 'number')\n            type = type.toString();\n        if (typeof actual === 'number')\n            actual = actual.toString();\n        (_a = this._errorManager).unexpectedValue.apply(_a, tslib_1.__spreadArray([this._pos, this._endPos, type, actual], tslib_1.__read(expected)));\n        return this;\n    };\n    /**\n     * Add an unexpected token error at the current token\n     * @param actual\tThe received tokens\n     * @param expected\tThe expected token(s)\n     */\n    StateManager.prototype.unexpectedToken = function (actual) {\n        var _a;\n        var expected = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            expected[_i - 1] = arguments[_i];\n        }\n        if (typeof actual === 'number')\n            actual = actual.toString();\n        (_a = this._errorManager).unexpectedToken.apply(_a, tslib_1.__spreadArray([this._pos, this._endPos, actual], tslib_1.__read(expected)));\n        return this;\n    };\n    /**\n     * Add an unexpected end-of-input error at the current token\n     * @param expected\tThe expected token(s)\n     */\n    StateManager.prototype.unexpectedEOI = function () {\n        var _a;\n        var expected = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            expected[_i] = arguments[_i];\n        }\n        (_a = this._errorManager).unexpectedEOI.apply(_a, tslib_1.__spreadArray([this._pos, this._endPos], tslib_1.__read(expected)));\n        return this;\n    };\n    StateManager.prototype.unexpectedEOICustom = function (msg) {\n        this.errorManager.addError(this._pos, \"Unexpected end of input: \" + msg, this._endPos);\n    };\n    StateManager.prototype.unexpectedTokenCustom = function (actual, msg) {\n        if (typeof actual === 'number')\n            actual = actual.toString();\n        if (actual) {\n            this.errorManager.addError(this._pos, \"Unexpected token \\\"\" + actual + \"\\\": \" + msg, this._endPos);\n        }\n        else {\n            this.errorManager.addError(this._pos, \"Unexpected token: \" + msg, this._endPos);\n        }\n    };\n    //Internal util methods\n    /**\n     * Pop and return the next token from the queue, and update the position counter.\n     * @returns {WHILE_TOKEN_EXTD}\tThe next token in the list\n     * @returns {null} \t\t\tIf the token list is empty\n     */\n    StateManager.prototype._next = function () {\n        //Read the next token in the list\n        var first = this._tokens.shift() || null;\n        //Increment the position counter\n        if (first !== null) {\n            //Move to the start of the next token\n            this._pos = tslib_1.__assign({}, first.pos);\n            this._endPos = tslib_1.__assign({}, first.endPos);\n            this._lastToken = first;\n        }\n        else {\n            //Move to the end of the last token\n            this._pos = tslib_1.__assign({}, this._endPos);\n        }\n        //Return the token\n        return first;\n    };\n    return StateManager;\n}());\n/**\n * Convert a number to it's binary tree representation\n * @param n\t\tThe number to convert\n */\nfunction _numToTree(n) {\n    //The created binary tree\n    var tree = null;\n    //Subtract 1 from the number each iteration\n    for (; n > 0; n--) {\n        //Add one more layer to the top of the tree\n        tree = {\n            left: null,\n            right: tree,\n        };\n    }\n    //Return the created tree\n    return tree;\n}\n/**\n * Check that a variable name doesn't overlap with any built-in constants.\n * @param name\tThe variable name\n * @param opts\tConfiguration options object\n * @returns true\tIf the name can be used for a variable name\n * @returns false\tIf the name overlaps with a constant\n */\nfunction _isValidVariableName(name, opts) {\n    //Pure language constants\n    if (name === extendedTokens_1.TKN_TRUE)\n        return false;\n    //Extended language constants\n    if (!opts.pureOnly) {\n        return name !== extendedTokens_1.TKN_FALSE\n            && name !== extendedTokens_1.TKN_TRUE;\n    }\n    //Is valid\n    return true;\n}\n// ================\n// Parser functions\n// ================\n/**\n * Read an expression (hd/tl/cons) from the token list.\n * Returns a list containing the parser segment status, and the parsed expression tree.\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @param checkEq\tWhether to check for an equality operator after the expression.\n * \t\t\t\t\tDefault {@code true}.\n * \t\t\t\t\tMainly for recursive calls.\n * @returns {[ParseStatus.OK, AST_EXPR]}\t\t\tThe parsed expression tree\n * @returns {[ParseStatus.ERROR, AST_EXPR|AST_EXPR_PARTIAL|null]}\tThe parsed expression with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n * @returns {[ParseStatus.EOI, AST_EXPR|AST_EXPR_PARTIAL|null]}\t\tThe parsed expression with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n */\nfunction _readExpr(state, opts, checkEq) {\n    var _a;\n    if (checkEq === void 0) { checkEq = true; }\n    function _readExprInt(state, opts) {\n        var first = state.next();\n        //Handle early end of input\n        if (first === null)\n            return [ParseStatus.EOI, null];\n        //Support brackets around expressions\n        if (first.value === tokens_1.TKN_PREN_OPN) {\n            var status_1 = ParseStatus.OK;\n            //Parse the expression between the brackets\n            var _a = tslib_1.__read(_readExpr(state, opts), 2), exprStatus = _a[0], expr = _a[1];\n            if (exprStatus !== ParseStatus.OK)\n                status_1 = exprStatus;\n            //Expect a closing parenthesis\n            var close_1 = state.next();\n            if (close_1 === null) {\n                state.unexpectedEOI(tokens_1.TKN_PREN_CLS);\n                status_1 = ParseStatus.OK;\n            }\n            else if (close_1.value === tokens_1.TKN_PREN_CLS) {\n                //Brackets match\n            }\n            else {\n                state.unexpectedToken(close_1.value, tokens_1.TKN_PREN_CLS);\n                status_1 = ParseStatus.ERROR;\n            }\n            //Return the result of the expression\n            return [status_1, expr];\n        }\n        if (first.type === 'operation') {\n            if (!opts.pureOnly) {\n                //Swap true/false values for their tree values\n                if (first.value === extendedTokens_1.TKN_FALSE) {\n                    //Convert to nil\n                    return [ParseStatus.OK, {\n                            type: 'tree',\n                            complete: true,\n                            tree: _numToTree(0)\n                        }];\n                }\n                if (first.value === extendedTokens_1.TKN_TRUE) {\n                    //Convert to <nil.nil>\n                    return [ParseStatus.OK, {\n                            type: 'tree',\n                            complete: true,\n                            tree: _numToTree(1)\n                        }];\n                }\n            }\n            //Parse `hd` and `tl`\n            if (first.value === tokens_1.TKN_HD || first.value === tokens_1.TKN_TL) {\n                var _b = tslib_1.__read(_readExpr(state, opts, false), 2), exprState = _b[0], arg = _b[1];\n                if (arg === null) {\n                    return [exprState, {\n                            type: 'operation',\n                            complete: false,\n                            op: astOp(first),\n                            args: [arg]\n                        }];\n                }\n                else if (arg.type === 'identName' || arg.complete) {\n                    //The argument is an identifier or complete operation\n                    return [exprState, {\n                            type: 'operation',\n                            complete: true,\n                            op: astOp(first),\n                            args: [arg]\n                        }];\n                }\n                else {\n                    //The argument is an incomplete operation\n                    return [exprState, {\n                            type: 'operation',\n                            complete: false,\n                            op: astOp(first),\n                            args: [arg]\n                        }];\n                }\n            }\n            //Parse `cons`\n            var _c = tslib_1.__read(_readExpr(state, opts, false), 2), leftStatus = _c[0], left = _c[1];\n            var _d = tslib_1.__read(_readExpr(state, opts, false), 2), rightStatus = _d[0], right = _d[1];\n            var status_2 = ParseStatus.OK;\n            if (leftStatus !== ParseStatus.OK)\n                status_2 = leftStatus;\n            if (rightStatus !== ParseStatus.OK)\n                status_2 = rightStatus;\n            if (!left || !right\n                || (left.type !== 'identName' && !left.complete)\n                || (right.type !== 'identName' && !right.complete)) {\n                return [status_2, {\n                        type: 'operation',\n                        complete: false,\n                        op: astOp(first),\n                        args: [\n                            left,\n                            right\n                        ]\n                    }];\n            }\n            else {\n                return [status_2, {\n                        type: 'operation',\n                        complete: true,\n                        op: astOp(first),\n                        args: [\n                            left,\n                            right\n                        ]\n                    }];\n            }\n        }\n        else if (first.type === 'identifier') {\n            if (first.value === TreeLexer_1.TKN_NIL) {\n                return [ParseStatus.OK, {\n                        type: 'tree',\n                        complete: true,\n                        tree: _numToTree(0)\n                    }];\n            }\n            return [\n                ParseStatus.OK,\n                astIdent(first),\n            ];\n            // return [ParseStatus.OK, {\n            // \ttype: 'identName',\n            // \tvalue: first.value\n            // }];\n        }\n        else {\n            if (!opts.pureOnly) {\n                if (first.type === 'number') {\n                    return [ParseStatus.OK, {\n                            type: 'tree',\n                            complete: true,\n                            tree: _numToTree(first.value)\n                        }];\n                }\n                else if (first.value === extendedTokens_1.TKN_LIST_OPN) {\n                    var _e = tslib_1.__read(_readListBody(state, opts), 2), lstStatus = _e[0], lstBody = _e[1];\n                    if (lstStatus === ParseStatus.OK) {\n                        return [lstStatus, {\n                                type: 'list',\n                                complete: true,\n                                elements: lstBody,\n                            }];\n                    }\n                    return [lstStatus, {\n                            type: 'list',\n                            complete: false,\n                            elements: lstBody,\n                        }];\n                }\n                else if (first.value === extendedTokens_1.TKN_MCRO_OPN) {\n                    return _readTreeOrMacro(state, opts);\n                }\n            }\n            state.unexpectedTokenCustom(first.value, 'Expected an expression or an identifier');\n            return [ParseStatus.ERROR, {\n                    type: 'operation',\n                    complete: false,\n                    op: null,\n                    args: []\n                }];\n        }\n    }\n    var _b = tslib_1.__read(_readExprInt(state, opts), 2), resStat = _b[0], res = _b[1];\n    //Check if this expression is an equality check\n    if (checkEq && !opts.pureOnly && ((_a = state.peek()) === null || _a === void 0 ? void 0 : _a.value) === extendedTokens_1.TKN_EQL) {\n        state.next();\n        var _c = tslib_1.__read(_readExpr(state, opts, checkEq), 2), nextStatus = _c[0], next = _c[1];\n        if (nextStatus === ParseStatus.OK) {\n            return [ParseStatus.OK, {\n                    type: 'equal',\n                    complete: true,\n                    arg1: res,\n                    arg2: next,\n                }];\n        }\n        return [nextStatus, {\n                type: 'equal',\n                complete: false,\n                arg1: res,\n                arg2: next,\n            }];\n    }\n    return [resStat, res];\n}\n/**\n * Read the content of a list statement from the program token list.\n * Assumes that the {@code TKN_LIST_OPN} token HAS been read from the token list.\n * Returns a list containing each element of the list, in order\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_SWITCH]}\t\t\tThe parsed element list\n * @returns {[ParseStatus.ERROR, (AST_EXPR|AST_EXPR_PARTIAL|null)[]]}\tThe parsed statement with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n * @returns {[ParseStatus.EOI, (AST_EXPR|AST_EXPR_PARTIAL|null)[]]}\tThe parsed statement with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n */\nfunction _readListBody(state, opts) {\n    //Exit here if the list ends immediately\n    var next = state.peek();\n    if (next === null) {\n        //Move the pointer to after the last token\n        state.next();\n        state.unexpectedEOI(extendedTokens_1.TKN_LIST_CLS);\n        return [ParseStatus.EOI, []];\n    }\n    else if (next.value === extendedTokens_1.TKN_LIST_CLS) {\n        //Consume the separator\n        state.next();\n        return [ParseStatus.OK, []];\n    }\n    var res = [];\n    var status = ParseStatus.OK;\n    while (true) {\n        var _a = tslib_1.__read(_readExpr(state, opts), 2), statementStatus = _a[0], statement = _a[1];\n        res.push(statement);\n        if (statementStatus === ParseStatus.EOI) {\n            //On end of input\n            status = statementStatus;\n            break;\n        }\n        else if (statementStatus === ParseStatus.ERROR) {\n            //On parsing error, consume the input until a separator token is reached\n            //Then start afresh\n            state.consumeUntil(extendedTokens_1.TKN_LIST_CLS, extendedTokens_1.TKN_COMMA);\n            status = ParseStatus.ERROR;\n        }\n        //Check that the next token is a comma or closing bracket\n        var next_1 = state.peek();\n        if (next_1 === null) {\n            status = ParseStatus.EOI;\n            //Move the pointer to after the last token\n            state.next();\n            state.unexpectedEOI(extendedTokens_1.TKN_COMMA, extendedTokens_1.TKN_LIST_CLS);\n            break;\n        }\n        else if (next_1.value === extendedTokens_1.TKN_COMMA) {\n            //Consume the separator to start clean next loop\n            state.next();\n            //Move on to the next statement\n            continue;\n        }\n        else if (next_1.value === extendedTokens_1.TKN_LIST_CLS) {\n            state.next();\n            break;\n        }\n        //Unknown token - consume the input until the next known position\n        state.consumeUntil(extendedTokens_1.TKN_COMMA, extendedTokens_1.TKN_LIST_CLS);\n    }\n    return [status, res];\n}\n/**\n * Read a tree statement from the program token list.\n * Assumes that the {@code TKN_TREE_OPN} token HAS been read from the token list.\n * Returns a list containing the parser segment status, and the parsed command tree\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_EXPR_TREE]}\t\t\tThe parsed switch statement\n * @returns {[ParseStatus.ERROR, AST_EXPR_TREE_PARTIAL]}\tThe parsed statement with {@code null} where information can't be parsed\n * @returns {[ParseStatus.EOI, AST_EXPR_TREE_PARTIAL]}\tThe parsed statement with {@code null} where information can't be parsed\n */\nfunction _readTreeBody(state, opts) {\n    var status = ParseStatus.OK;\n    //Read the left-hand node\n    var _a = tslib_1.__read(_readExpr(state, opts), 2), leftStatus = _a[0], left = _a[1];\n    if (leftStatus === ParseStatus.EOI) {\n        return [ParseStatus.EOI, {\n                type: 'tree_expr',\n                complete: false,\n                left: left,\n                right: null,\n            }];\n    }\n    if (leftStatus !== ParseStatus.OK)\n        status = leftStatus;\n    //Check that the next token is a dot separating the elements\n    var _b = tslib_1.__read(state.expect(extendedTokens_1.TKN_DOT), 1), dotStatus = _b[0];\n    if (dotStatus === ParseStatus.EOI) {\n        return [ParseStatus.EOI, {\n                type: 'tree_expr',\n                complete: false,\n                left: left,\n                right: null,\n            }];\n    }\n    if (dotStatus !== ParseStatus.OK)\n        status = dotStatus;\n    //Read the right-hand node\n    var _c = tslib_1.__read(_readExpr(state, opts), 2), rightStatus = _c[0], right = _c[1];\n    if (rightStatus === ParseStatus.EOI) {\n        return [ParseStatus.EOI, {\n                type: 'tree_expr',\n                complete: false,\n                left: left,\n                right: right,\n            }];\n    }\n    if (rightStatus !== ParseStatus.OK)\n        status = rightStatus;\n    //Read the closing tree bracket\n    var _d = tslib_1.__read(state.expect(extendedTokens_1.TKN_MCRO_CLS), 1), clsStatus = _d[0];\n    if (clsStatus !== ParseStatus.OK)\n        status = clsStatus;\n    //Return the tree\n    if (status === ParseStatus.OK) {\n        return [status, {\n                type: 'tree_expr',\n                complete: true,\n                left: left,\n                right: right,\n            }];\n    }\n    return [status, {\n            type: 'tree_expr',\n            complete: false,\n            left: left,\n            right: right,\n        }];\n}\n/**\n * Read either a tree statement or a macro call from the program token list.\n * Assumes that the {@code TKN_TREE_OPN} token HAS been read from the token list.\n * Returns a list containing the parser segment status, and the produced AST\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_EXPR_TREE]}\t\t\tThe parsed switch statement\n * @returns {[ParseStatus.ERROR, AST_EXPR_TREE_PARTIAL]}\tThe parsed statement with {@code null} where information can't be parsed\n * @returns {[ParseStatus.EOI, AST_EXPR_TREE_PARTIAL]}\tThe parsed statement with {@code null} where information can't be parsed\n */\nfunction _readTreeOrMacro(state, opts) {\n    var _a, _b;\n    //If the token list starts with `identifier>` then assume it is a macro call\n    if (((_a = state.peek()) === null || _a === void 0 ? void 0 : _a.type) === 'identifier' && ((_b = state.peek(1)) === null || _b === void 0 ? void 0 : _b.value) === extendedTokens_1.TKN_MCRO_CLS) {\n        var status_3 = ParseStatus.OK;\n        //The program name\n        var progName = state.next().value;\n        //Check that the next token is a dot separating the elements\n        var _c = tslib_1.__read(state.expect(extendedTokens_1.TKN_MCRO_CLS), 1), clsStatus = _c[0];\n        if (clsStatus === ParseStatus.EOI) {\n            return [ParseStatus.EOI, {\n                    type: 'macro',\n                    complete: false,\n                    input: null,\n                    program: progName,\n                }];\n        }\n        if (clsStatus !== ParseStatus.OK)\n            status_3 = clsStatus;\n        //Read the input expression\n        var _d = tslib_1.__read(_readExpr(state, opts), 2), inpStatus = _d[0], inp = _d[1];\n        if (inpStatus === ParseStatus.EOI) {\n            return [ParseStatus.EOI, {\n                    type: 'macro',\n                    complete: false,\n                    program: progName,\n                    input: inp,\n                }];\n        }\n        if (inpStatus !== ParseStatus.OK)\n            status_3 = inpStatus;\n        //Return the macro call node\n        if (status_3 === ParseStatus.OK) {\n            return [status_3, {\n                    type: 'macro',\n                    complete: true,\n                    program: progName,\n                    input: inp,\n                }];\n        }\n        return [status_3, {\n                type: 'macro',\n                complete: false,\n                program: progName,\n                input: inp,\n            }];\n    }\n    //Otherwise assume the token list is representing a tree\n    return _readTreeBody(state, opts);\n}\n/**\n * Read the contents of an else block from the token list.\n * Returns a list containing the parser segment status, and list of parsed command trees\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, (AST_CMD)[]]}\t\t\tList of each statement in the else block\n * @returns {[ParseStatus.ERROR, (AST_CMD|AST_CMD_PARTIAL|null)[]]}\tList of each statement in the else block, if readable, {@code null} where not possible\n * @returns {[ParseStatus.EOI, (AST_CMD|AST_CMD_PARTIAL|null)[]]}\tList of each statement in the else block, if readable, {@code null} where not possible\n */\nfunction _readElse(state, opts) {\n    var peek = state.peek();\n    if (peek === null) {\n        //Unexpected end of input\n        state.unexpectedEOI(tokens_1.TKN_BLOCK_CLS);\n        return [ParseStatus.EOI, []];\n    }\n    else if (peek.value === tokens_1.TKN_ELSE) {\n        //An else statement was provided\n        state.next();\n        return _readBlock(state, opts);\n    }\n    else {\n        //Assume there wasn't meant to be an else statement\n        //I.e. treat it the same as `else {}`\n        return [ParseStatus.OK, []];\n    }\n}\n/**\n * Read a list of statements (separated by semicolons) from the program token list.\n * Assumes that the first token has NOT been read from the token list.\n * Returns a list containing the parser segment status, and a list of the parsed statements\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_CMD[]]}\t\t\tThe parsed statement list\n * @returns {[ParseStatus.ERROR, (AST_CMD_PARTIAL|null)[]]}\tThe parsed statement list with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n * @returns {[ParseStatus.EOI, (AST_CMD_PARTIAL|null)[]]}\tThe parsed statement list with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n */\nfunction _readStatementList(state, opts) {\n    var res = [];\n    var status = ParseStatus.OK;\n    while (true) {\n        var _a = tslib_1.__read(_readStmt(state, opts), 2), statementStatus = _a[0], statement = _a[1];\n        res.push(statement);\n        if (statementStatus === ParseStatus.EOI) {\n            //On end of input\n            status = statementStatus;\n            break;\n        }\n        else if (statementStatus === ParseStatus.ERROR) {\n            //On parsing error, consume the input until a separator token is reached\n            //Then start afresh\n            state.consumeUntil(tokens_1.TKN_BLOCK_CLS, tokens_1.TKN_SEP);\n            status = ParseStatus.ERROR;\n        }\n        //Check that the next token is a statement separator or\n        var next = state.peek();\n        if (next === null) {\n            status = ParseStatus.EOI;\n            //Move the pointer to after the last token\n            state.next();\n            state.unexpectedEOI(tokens_1.TKN_SEP, tokens_1.TKN_BLOCK_CLS);\n            break;\n        }\n        else if (next.value === tokens_1.TKN_SEP) {\n            //Consume the separator to start clean next loop\n            state.next();\n            //Move on to the next statement\n            continue;\n        }\n        break;\n    }\n    return [status, res];\n}\n/**\n * Read a switch's {@code case}/{@code default} statement from the program token list.\n * Assumes that the {@code TKN_CASE}/{@code TKN_DEFAULT} token has NOT been read from the token list.\n * Returns a list containing the parser segment status, and the parsed command tree\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_SWITCH_CASE|AST_SWITCH_DEFAULT]}\t\t\tThe parsed case statement\n * @returns {[ParseStatus.ERROR, AST_SWITCH_CASE_PARTIAL|AST_SWITCH_DEFAULT_PARTIAL|null]}\tThe parsed statement with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n * @returns {[ParseStatus.EOI, AST_SWITCH_CASE_PARTIAL|AST_SWITCH_DEFAULT_PARTIAL|null]}\tThe parsed statement with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n */\nfunction _readCase(state, opts) {\n    /**\n     * Internal function to read the common parts of case/default statements.\n     * i.e. the ': <body>' parts.\n     *\n     * Returns a list containing the parser segment status, and the parsed command tree\n     * @param state\t\tThe parser state manager object\n     * @returns {[ParseStatus.OK, AST_CMD[]]}\t\t\tThe parsed case statement body\n     * @returns {[ParseStatus.ERROR, (AST_CMD|AST_CMD_PARTIAL|null)[]]}\tThe parsed body with {@code null} where information can't be parsed\n     * @returns {[ParseStatus.EOI, (AST_CMD|AST_CMD_PARTIAL|null)[]]}\tThe parsed body with {@code null} where information can't be parsed\n     */\n    function _readCaseBody(state) {\n        var _a;\n        var _b, _c, _d;\n        //Expect a colon after the case definition\n        var _e = tslib_1.__read(state.expect(extendedTokens_1.TKN_COLON), 1), colonStat = _e[0];\n        if (colonStat !== ParseStatus.OK)\n            status = colonStat;\n        //Parse the case body\n        var body;\n        if (colonStat === ParseStatus.EOI) {\n            status = ParseStatus.EOI;\n            body = [];\n        }\n        else if (((_b = state.peek()) === null || _b === void 0 ? void 0 : _b.value) === extendedTokens_1.TKN_CASE || ((_c = state.peek()) === null || _c === void 0 ? void 0 : _c.value) === extendedTokens_1.TKN_DEFAULT || ((_d = state.peek()) === null || _d === void 0 ? void 0 : _d.value) === tokens_1.TKN_BLOCK_CLS) {\n            status = ParseStatus.ERROR;\n            body = [];\n            state.addError(\"Switch cases may not have empty bodies\");\n        }\n        else {\n            var bodyStatus = void 0;\n            _a = tslib_1.__read(_readStatementList(state, opts), 2), bodyStatus = _a[0], body = _a[1];\n            if (bodyStatus !== ParseStatus.OK)\n                status = bodyStatus;\n        }\n        return [status, body];\n    }\n    //Read the case/default token from the list\n    var caseTkn = state.next();\n    if (caseTkn === null)\n        return [ParseStatus.EOI, null];\n    //Hold the parsing status for this case\n    var status;\n    if (caseTkn.value === extendedTokens_1.TKN_DEFAULT) {\n        //The statement is a \"default\" case\n        status = ParseStatus.OK;\n        //Read the body of the case statement\n        var _a = tslib_1.__read(_readCaseBody(state), 2), caseStatus = _a[0], body = _a[1];\n        if (caseStatus !== ParseStatus.OK)\n            status = caseStatus;\n        if (status === ParseStatus.OK) {\n            //The statement was all parsed correctly\n            return [status, {\n                    type: 'switch_default',\n                    complete: true,\n                    body: body\n                }];\n        }\n        //The statement was parsed with issues\n        return [status, {\n                type: 'switch_default',\n                complete: false,\n                body: body\n            }];\n    }\n    else if (caseTkn.value === extendedTokens_1.TKN_CASE) {\n        //Read the case's expression\n        var _b = tslib_1.__read(_readExpr(state, opts), 2), exprStatus = _b[0], expr = _b[1];\n        if (exprStatus === ParseStatus.EOI)\n            return [ParseStatus.EOI, { type: 'switch_case', complete: false, body: [], cond: expr }];\n        //Check the expression was parsed correctly\n        status = exprStatus;\n        if (expr === null || expr.type !== 'identName' && expr.type !== 'tree' && !expr.complete) {\n            status = ParseStatus.ERROR;\n        }\n        //Read the body of the case statement\n        var _c = tslib_1.__read(_readCaseBody(state), 2), caseStatus = _c[0], body = _c[1];\n        if (caseStatus !== ParseStatus.OK)\n            status = caseStatus;\n        if (status === ParseStatus.OK) {\n            //The statement was all parsed correctly\n            return [status, {\n                    type: 'switch_case',\n                    complete: true,\n                    cond: expr,\n                    body: body\n                }];\n        }\n        //The statement was parsed with issues\n        return [status, {\n                type: 'switch_case',\n                complete: false,\n                cond: expr,\n                body: body\n            }];\n    }\n    else {\n        //Unknown case\n        state.unexpectedToken(caseTkn.value, extendedTokens_1.TKN_CASE, extendedTokens_1.TKN_DEFAULT);\n        return [ParseStatus.ERROR, null];\n    }\n}\n/**\n * Read a switch statement from the program token list.\n * Assumes that the {@code TKN_SWITCH} token HAS been read from the token list.\n * Returns a list containing the parser segment status, and the parsed command tree\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_SWITCH]}\t\t\tThe parsed switch statement\n * @returns {[ParseStatus.ERROR, AST_SWITCH_PARTIAL|null]}\tThe parsed statement with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n * @returns {[ParseStatus.EOI, AST_SWITCH_PARTIAL|null]}\tThe parsed statement with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n */\nfunction _readSwitch(state, opts) {\n    var _a;\n    var status = ParseStatus.OK;\n    //Expression passed as input to  the switch\n    var _b = tslib_1.__read(_readExpr(state, opts), 2), inpStatus = _b[0], inpExpr = _b[1];\n    if (inpStatus === ParseStatus.EOI)\n        return [ParseStatus.EOI, null];\n    if (inpStatus !== ParseStatus.OK)\n        status = inpStatus;\n    //Build up the switch cases and default value\n    var cases = [];\n    var dflt = null;\n    //Expect a \"{\" to open the switch\n    var _c = tslib_1.__read(state.expect(tokens_1.TKN_BLOCK_OPN), 1), opnStatus = _c[0];\n    if (opnStatus === ParseStatus.EOI)\n        return [ParseStatus.EOI, null];\n    if (opnStatus !== ParseStatus.OK)\n        status = opnStatus;\n    //Read all the cases\n    var next;\n    while ((next = state.peek()) !== null) {\n        if (next.value !== extendedTokens_1.TKN_DEFAULT && next.value !== extendedTokens_1.TKN_CASE)\n            break;\n        //The default case should be the last in the switch\n        if (dflt !== null) {\n            status = ParseStatus.ERROR;\n            state.errorManager.addError(next.pos, \"The 'default' case should be the last case in the block\", next.endPos);\n        }\n        //Read the next case statement and body from the token list\n        var caseStatus = void 0;\n        var body = void 0;\n        _a = tslib_1.__read(_readCase(state, opts), 2), caseStatus = _a[0], body = _a[1];\n        //Update the status if the case wasn't parsed completely\n        if (caseStatus !== ParseStatus.OK)\n            status = caseStatus;\n        if (status === ParseStatus.EOI) {\n            //Unexpected end of input\n            break;\n        }\n        else if (body === null) {\n            cases.push(body);\n        }\n        else if (body.type === 'switch_case') {\n            //A case statement\n            cases.push(body);\n        }\n        else {\n            //A default statement\n            dflt = body;\n        }\n    }\n    //Create an empty default case if one wasn't provided\n    if (dflt === null) {\n        dflt = {\n            type: 'switch_default',\n            complete: true,\n            body: []\n        };\n    }\n    //Expect a closing block symbol\n    var _d = tslib_1.__read(state.expect(tokens_1.TKN_BLOCK_CLS), 1), s = _d[0];\n    if (s !== ParseStatus.OK)\n        status = s;\n    if (status === ParseStatus.OK) {\n        //If the switch was parsed without issue, return a completed switch AST node\n        return [\n            status,\n            {\n                type: 'switch',\n                complete: true,\n                condition: inpExpr,\n                cases: cases,\n                default: dflt,\n            }\n        ];\n    }\n    //Otherwise return a partial AST node\n    return [\n        status,\n        {\n            type: 'switch',\n            complete: false,\n            condition: inpExpr,\n            cases: cases,\n            default: dflt,\n        }\n    ];\n}\n/**\n * Read a statement (if/if-else/while/assignment) from the program token list.\n * Returns a list containing the parser segment status, and the parsed command tree\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_CMD]}\t\t\tThe parsed statement\n * @returns {[ParseStatus.ERROR, AST_CMD_PARTIAL|null]}\tThe parsed statement with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n * @returns {[ParseStatus.EOI, AST_CMD_PARTIAL|null]}\tThe parsed statement with {@code null} where information can't be parsed, or {@code null} if it is unreadable\n */\nfunction _readStmt(state, opts) {\n    var first = state.next();\n    //Handle early end of input\n    if (first === null) {\n        return [ParseStatus.EOI, null];\n    }\n    if (first.value === tokens_1.TKN_IF) {\n        //First attempt to read the condition expression\n        var _a = tslib_1.__read(_readExpr(state, opts), 2), condStatus = _a[0], cond = _a[1];\n        //Then read the conditional body\n        var _b = tslib_1.__read(_readBlock(state, opts), 2), ifState = _b[0], ifBlock = _b[1];\n        //And the 'else' body\n        var _c = tslib_1.__read(_readElse(state, opts), 2), elseState = _c[0], elseBlock = _c[1];\n        //Return success if all the segments were parsed correctly\n        if (cond !== null && (cond.type === 'identName' || cond.type === 'tree' || cond.complete) && condStatus === ParseStatus.OK && ifState === ParseStatus.OK && elseState === ParseStatus.OK) {\n            //Return the produced AST node\n            return [\n                ParseStatus.OK,\n                {\n                    type: 'cond',\n                    complete: true,\n                    condition: cond,\n                    if: ifBlock,\n                    else: elseBlock,\n                }\n            ];\n        }\n        return [\n            ParseStatus.ERROR,\n            {\n                type: 'cond',\n                complete: false,\n                condition: cond,\n                if: ifBlock,\n                else: elseBlock,\n            }\n        ];\n    }\n    else if (first.value === tokens_1.TKN_WHILE) {\n        var status_4 = ParseStatus.OK;\n        var _d = tslib_1.__read(_readExpr(state, opts), 2), condStatus = _d[0], cond = _d[1];\n        if (condStatus !== ParseStatus.OK)\n            status_4 = condStatus;\n        if (condStatus === ParseStatus.EOI)\n            return [ParseStatus.EOI, null];\n        var _e = tslib_1.__read(_readBlock(state, opts), 2), bodyState = _e[0], body = _e[1];\n        if (bodyState !== ParseStatus.OK)\n            status_4 = bodyState;\n        if (status_4 === ParseStatus.OK) {\n            return [\n                ParseStatus.OK,\n                {\n                    type: 'loop',\n                    complete: true,\n                    condition: cond,\n                    body: body,\n                }\n            ];\n        }\n        else {\n            return [\n                status_4,\n                {\n                    type: 'loop',\n                    complete: false,\n                    condition: cond,\n                    body: body,\n                }\n            ];\n        }\n    }\n    else if (first.type === 'identifier') {\n        var status_5 = ParseStatus.OK;\n        //The expression is an assignment statement\n        //Check that the variable name doesn't overlap with a constant\n        var isVarValid = _isValidVariableName(first.value, opts);\n        if (!isVarValid)\n            state.addError(\"Not a valid variable name\");\n        //Expect \":=\"\n        var _f = tslib_1.__read(state.expect(tokens_1.TKN_ASSGN), 1), assgnStatus = _f[0];\n        if (assgnStatus === ParseStatus.EOI)\n            return [ParseStatus.EOI, null];\n        if (assgnStatus !== ParseStatus.OK)\n            status_5 = assgnStatus;\n        //Read the expression to assign\n        var _g = tslib_1.__read(_readExpr(state, opts), 2), valStatus = _g[0], val = _g[1];\n        if (valStatus === ParseStatus.EOI)\n            return [ParseStatus.EOI, null];\n        if (valStatus !== ParseStatus.OK)\n            status_5 = valStatus;\n        if (isVarValid && status_5 === ParseStatus.OK && val !== null && (val.type === 'identName' || val.complete)) {\n            return [\n                ParseStatus.OK,\n                {\n                    type: 'assign',\n                    complete: true,\n                    ident: astIdent(first),\n                    arg: val\n                }\n            ];\n        }\n        return [\n            ParseStatus.ERROR,\n            {\n                type: 'assign',\n                complete: false,\n                ident: astIdent(first),\n                arg: val\n            }\n        ];\n    }\n    else if (!opts.pureOnly) {\n        //The statement is a switch\n        if (first.value === extendedTokens_1.TKN_SWITCH) {\n            return _readSwitch(state, opts);\n        }\n    }\n    state.unexpectedTokenCustom(undefined, \"Expected \" + tokens_1.TKN_IF + \" \" + tokens_1.TKN_WHILE + \" or an assignment statement\");\n    return [ParseStatus.ERROR, null];\n}\n/**\n * Read a block of statements from the token list.\n * Returns a list containing the parser segment status, and the list of the parsed command trees.\n * See also: {@link _readStmt}\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_CMD[]]}\t\t\tList of each statement in the block\n * @returns {[ParseStatus.ERROR, (AST_CMD_PARTIAL|null)[]]}\tList of each statement, if readable, {@code null} where not possible\n * @returns {[ParseStatus.EOI, (AST_CMD_PARTIAL|null)[]]}\tList of each statement, if readable, {@code null} where not possible\n */\nfunction _readBlock(state, opts) {\n    state.expect(tokens_1.TKN_BLOCK_OPN);\n    var first = state.peek();\n    if (first === null) {\n        state.next();\n        state.unexpectedEOI(tokens_1.TKN_BLOCK_CLS);\n        return [ParseStatus.EOI, []];\n    }\n    if (first.value === tokens_1.TKN_BLOCK_CLS) {\n        //Empty loop body\n        state.next();\n        return [ParseStatus.OK, []];\n    }\n    //Read a list of statements for the block body\n    var _a = tslib_1.__read(_readStatementList(state, opts), 2), status = _a[0], res = _a[1];\n    if (status === ParseStatus.EOI)\n        return [status, res];\n    //Expect a closing bracket\n    var _b = tslib_1.__read(state.expect(tokens_1.TKN_BLOCK_CLS), 1), clsStat = _b[0];\n    if (clsStat === ParseStatus.EOI)\n        return [clsStat, res];\n    //Return the produced AST\n    if (status === ParseStatus.OK && clsStat === ParseStatus.OK)\n        return [ParseStatus.OK, res];\n    return [ParseStatus.ERROR, res];\n}\n/**\n * Read the \"<name> read <input>\" from the start of the token list.\n * Returns a list containing the parser segment status, the program name, and the input variable.\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_IDENT_NAME, AST_IDENT_NAME]}\t\t\tThe program name, and input variable\n * @returns {[ParseStatus.ERROR, AST_IDENT_NAME|null, AST_IDENT_NAME|null]}\tThe program name and input variable if readable, {@code null} for each otherwise\n * @returns {[ParseStatus.EOI, AST_IDENT_NAME|null, AST_IDENT_NAME|null]}\tThe program name and input variable if readable, {@code null} for each otherwise\n */\nfunction _readProgramIntro(state, opts) {\n    function _readInput(state, opts) {\n        var input = state.peek();\n        if (input === null) {\n            state.next();\n            state.unexpectedEOICustom(\"Missing input variable\");\n            return [ParseStatus.EOI, null];\n        }\n        else if (input.value === tokens_1.TKN_BLOCK_OPN) {\n            state.errorManager.addError(input.pos, \"Unexpected token \\\"\" + input.value + \"\\\": Missing input variable\", input.endPos);\n            return [ParseStatus.ERROR, null];\n        }\n        else if (input.type === 'identifier') {\n            if (!_isValidVariableName(input.value, opts)) {\n                //Invalid variable name\n                state.addError(\"Not a valid variable name\");\n                state.next();\n                return [ParseStatus.ERROR, astIdent(input)];\n            }\n            //Acceptable token\n            state.next();\n            return [ParseStatus.OK, astIdent(input)];\n        }\n        else {\n            state.next();\n            //Not an identifier\n            state.unexpectedValue('type', input.type, 'identifier');\n            return [ParseStatus.ERROR, null];\n        }\n    }\n    function _readRead(state, opts) {\n        //\"read\"\n        var read = state.peek();\n        if (read === null) {\n            state.next();\n            state.unexpectedEOI(tokens_1.TKN_READ);\n            return [ParseStatus.EOI, null];\n        }\n        else if (read.value === tokens_1.TKN_READ) {\n            state.next();\n            //Expected\n            return _readInput(state, opts);\n        }\n        else if (read.value === tokens_1.TKN_BLOCK_OPN) {\n            //The program opens directly onto the block\n            state.errorManager.unexpectedToken(read.pos, read.endPos, undefined, tokens_1.TKN_READ);\n            return [ParseStatus.ERROR, null];\n        }\n        else {\n            state.next();\n            state.unexpectedToken(read.value, tokens_1.TKN_READ);\n            return [\n                ParseStatus.ERROR,\n                (read.type === 'identifier') ? astIdent(read) : null\n            ];\n        }\n    }\n    //Program name\n    var name = state.peek();\n    if (name === null) {\n        state.next();\n        state.unexpectedEOICustom(\"Missing program name\");\n        return [ParseStatus.EOI, null, null];\n    }\n    else if (name.value === tokens_1.TKN_READ) {\n        state.next();\n        //The program name was missed\n        state.errorManager.addError(name.pos, 'Unexpected token: Missing program name', name.endPos);\n        var _a = tslib_1.__read(_readInput(state, opts), 2), inputStatus = _a[0], input = _a[1];\n        if (inputStatus === ParseStatus.OK) {\n            return [ParseStatus.OK, null, input];\n        }\n        else {\n            return [ParseStatus.ERROR, null, input];\n        }\n    }\n    else if (name.value === tokens_1.TKN_BLOCK_OPN) {\n        //The program opens directly onto the block\n        state.errorManager.addError(name.pos, 'Unexpected token: Missing program name', name.endPos);\n        state.errorManager.unexpectedToken(name.pos, name.endPos, undefined, tokens_1.TKN_READ);\n        return [ParseStatus.ERROR, null, null];\n    }\n    else {\n        state.next();\n        var _b = tslib_1.__read(_readRead(state, opts), 2), inputStatus = _b[0], inputVar = _b[1];\n        //A program name wasn't provided\n        if (name.type !== 'identifier') {\n            state.unexpectedValue('type', name.type, 'identifier');\n            return [ParseStatus.ERROR, null, inputVar];\n        }\n        if (inputStatus === ParseStatus.OK) {\n            //Acceptable token\n            return [ParseStatus.OK, astIdent(name), inputVar];\n        }\n        return [inputStatus, astIdent(name), inputVar];\n    }\n}\n/**\n * Read \"write <output>\" from the start of the token list.\n * Returns a list containing the parser segment status, and the output variable.\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns {[ParseStatus.OK, AST_IDENT_NAME]}\t\t\tThe output variable\n * @returns {[ParseStatus.ERROR, AST_IDENT_NAME|null]}\tThe output variable, if readable, {@code null} otherwise\n * @returns {[ParseStatus.EOI, AST_IDENT_NAME|null]}\tThe output variable, if readable, {@code null} otherwise\n */\nfunction _readProgramOutro(state, opts) {\n    var err = ParseStatus.OK;\n    var output = null;\n    //read the \"write\" token\n    var write = state.next();\n    if (write === null) {\n        //Unexpected end of input\n        state.unexpectedEOI(tokens_1.TKN_WRITE);\n        return [ParseStatus.EOI, null];\n    }\n    else if (write.value === tokens_1.TKN_WRITE) {\n        //Expected value\n    }\n    else if (write.type === 'identifier') {\n        //Assume the \"write\" token was missed and the output variable was written directly\n        state.unexpectedToken(write.value, tokens_1.TKN_WRITE);\n        err = ParseStatus.ERROR;\n        output = astIdent(write);\n    }\n    else {\n        //Unknown token\n        state.unexpectedValue(write.type, write.value, tokens_1.TKN_WRITE);\n        err = ParseStatus.ERROR;\n    }\n    //Output variable\n    var outputVar = state.next();\n    if (outputVar === null) {\n        state.unexpectedEOI('identifier');\n        err = ParseStatus.EOI;\n    }\n    else if (outputVar.type === 'identifier') {\n        output = astIdent(outputVar);\n    }\n    else {\n        state.unexpectedTokenCustom(outputVar.value, \" Expected an identifier\");\n        err = ParseStatus.ERROR;\n    }\n    //Check the variable name is valid\n    if (output !== null && !_isValidVariableName(output.value, opts)) {\n        state.addError(\"Not a valid variable name\");\n    }\n    return [err, output];\n}\n/**\n * Read the root structure of a program from the token list\n * This is the {@code <prog> read <in> { ... } write <out>}\n * @param state\t\tThe parser state manager object\n * @param opts\t\tConfiguration options object\n * @returns AST_PROG\t\t\tWhen a program was parsed without issue\n * @returns AST_PROG_PARTIAL\tWhen at least one error was encountered with the program\n */\nfunction _readProgram(state, opts) {\n    var _a, _b;\n    var bodyStatus = ParseStatus.OK;\n    var outputStatus = ParseStatus.OK;\n    var body = [];\n    var output = null;\n    //Attempt to read the start of the program (\"<name> read <in>\")\n    //Separate into the program name and input variable name\n    var _c = tslib_1.__read(_readProgramIntro(state, opts), 3), progInStatus = _c[0], name = _c[1], input = _c[2];\n    //Don't attempt to parse the program if the input has already ended\n    if (progInStatus !== ParseStatus.EOI) {\n        //Read the program body\n        _a = tslib_1.__read(_readBlock(state, opts), 2), bodyStatus = _a[0], body = _a[1];\n        if (bodyStatus !== ParseStatus.EOI) {\n            //Read the outro of the program (\"write <out>\")\n            _b = tslib_1.__read(_readProgramOutro(state, opts), 2), outputStatus = _b[0], output = _b[1];\n            //Expect that the token list ends here\n            var final = state.next();\n            if (final !== null) {\n                state.unexpectedTokenCustom(final.value, 'Expected end of input');\n            }\n        }\n    }\n    //Mark the produced AST as complete if all the subtrees are valid\n    if (name && input && output && (bodyStatus === ParseStatus.OK) && (progInStatus === ParseStatus.OK) && (outputStatus === ParseStatus.OK)) {\n        //Return the produced program\n        return {\n            type: 'program',\n            complete: true,\n            input: input,\n            output: output,\n            name: name,\n            body: body,\n        };\n    }\n    //Otherwise mark it as incomplete\n    return {\n        type: 'program',\n        complete: false,\n        input: input,\n        output: output,\n        name: name,\n        body: body,\n    };\n}\n/**\n * Parse a token list (from the lexer) to an abstract syntax tree.\n * @param tokens\tThe program tokens to parse\n * @param props\t\tConfiguration options for the parser\n * @return\tAn abstract syntax tree representing the program, and a list of all the errors in the program\n */\nfunction parser(tokens, props) {\n    props = props || {};\n    var opts = {\n        pureOnly: props.pureOnly || false,\n    };\n    //Make a state manager object for use in the parser\n    var stateManager = new StateManager(tokens);\n    //Parse the program\n    var prog = _readProgram(stateManager, opts);\n    //Return the program and any discovered errors\n    return [prog, stateManager.errors];\n}\nexports.default = parser;\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}